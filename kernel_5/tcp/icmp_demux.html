<html>
<head>
<title>COLDFORTH KERNEL</title>
<META NAME="Author" CONTENT="Charles Esson">
<META NAME="keywords" CONTENT="forth"> 
<META NAME="description" CONTENT=" COLDFORTH uses this file to generate COLDFORTH">
<LINK REL=stylesheet HREF="../forth.css" TYPE="text/css">
</head>

<body>
<h3>Internet Control Message Protocol</h3>
<a HREF="./license.html">license</a><br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc0792.html">RFC792</a> Original<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1122.html">RFC1122</a> Updated<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc0896.html">RFC896</a> ICMP source quench<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1122.html">RFC1016</a> More recent source quench<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc0950.html">RFC950</a> Subnet mask<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc0956.html">RFC956</a> Clock<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc0957.html">RFC957</a> Clock<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1305.html">RFC1305</a> Clock<br>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1812.html">RFC1812</a> Router requirments<br>
<p>
How ICMP behaves has varied with time, and it would be safe to say the
situation is a mess.
</p>
<p>
This bit of code deals with ICMP messages received. It attempts to
deal with them in an intelligent manner.
</p>
<p>
ICMP messages are generated by the rest of the stack when the appropiate 
situation arises. They are sent as normal ip messages, and most will be 
sent out on the wire and never seen here.
</p>
<p>
Unfortunatly comer predates a lot of this stuff; so you need to read the RFC and
try and get some understanding of what is being attempted.
</p>
<h4>Redirect message</h4>
<p>
For your reading pleasure
</p>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc792.html">RFC792</a>.  
	<p>
      The gateway sends a redirect message to a host in the following
      situation.  A gateway, G1, receives an internet datagram from a
      host on a network to which the gateway is attached.  The gateway,
      G1, checks its routing table and obtains the address of the next
      gateway, G2, on the route to the datagram's internet destination
      network, X.  If G2 and the host identified by the internet source
      address of the datagram are on the same network, a redirect
      message is sent to the host.  The redirect message advises the
      host to send its traffic for network X directly to gateway G2 as
      this is a shorter path to the destination.  The gateway forwards
      the original datagram's data to its internet destination.
	</p>
	<h5>So getting it clear in my own mind</h5>
	<p>
	There are three pieces of info. The destination address in the original
	datagram. Thats what we are being asked to redirect. The source address of the
	ICMP message. Thats is who is asking us to redirect. And the destination
	address of the ICMP datgram gives us the interface over which the redirect came.
	The data field contains the address of the new gateway. In theory the gateway
	we sent it to and the gateway we redirect to will be on the same net. If it isn't 
	we don't accept the change. 
	</p>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1812.html">RFC1812</a>
	<h5>5.2.7.2 Redirect</h5>
<p>
The ICMP Redirect message is generated to inform a local host the it
should use a different next hop router for a certain class of
traffic.
</p>
<p>
Routers MUST NOT generate the Redirect for Network or Redirect for
Network and Type of Service messages (Codes 0 and 2) specified in
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc792.html">RFC792</a>.  
Routers MUST be able to generate the Redirect for Host
message (Code 1) and SHOULD be able to generate the Redirect for Type
of Service and Host message (Code 3) specified in 
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc792.html">RFC792</a>.  

From <a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1122.html">RFC1122 Section 3.2.2.2</a>
<p> 
A host SHOULD NOT send an ICMP Redirect message; Redirects are to be sent only by gateways.
</p>
<p>
A host receiving a Redirect message MUST update its routing information accordingly.  
Every host MUST be prepared to accept both Host and Network Redirects and to process them
as described in Section 3.3.1.2 below.
</p>
<p> 
A Redirect message SHOULD be silently discarded if the new
gateway address it specifies is not on the same connected
(sub-) net through which the Redirect arrived [INTRO:2,
Appendix A], or if the source of the Redirect is not the
current first-hop gateway for the specified destination (see
Section 3.3.1).
</p> 
<p>
<b>DISCUSSION</b>
If the directly connected network is not subnetted (in the
classical sense), a router can normally generate a network
Redirect that applies to all hosts on a specified remote network.
Using a network rather than a host Redirect may economize slightly
on network traffic and on host routing table storage.  However,
the savings are not significant, and subnets create an ambiguity
about the subnet mask to be used to interpret a network Redirect.
In a CIDR environment, it is difficult to specify precisely the
cases in which network Redirects can be used.  Therefore, routers
must send only host (or host and type of service) Redirects.
</p>
<p>
A Code 3 (Redirect for Host and Type of Service) message is generated
when the packet provoking the redirect has a destination for which
the path chosen by the router would depend (in part) on the TOS
requested.
</p>
<p>
<b>Conclusion</b> If you get a net redirect it is an old router. I think however you
should take note. If it is an old router it may be the best you get.
</p>
<p>
Remember redirect only deals with connected networks. And is saying hay dumbo, this
other gateway is connected to the same net as I am, I am about to send the packet
to that gateway, why in the hell don't you send it there instead of wasting my time?
</p>
	<pre> <code>
	| : icmp_redirect { variable %pep -- }{
		variable %route_entry
		variable %tos
		variable %ipdata
		}

		\ only accept codes that have been defined when code was written
		%pep @ ep_ipdata + @  %ipdata !
		%ipdata @ ic_code + B@
		DUP ICC_LAST_DEFINED > IF
			DROP
			%pep @ kill_free_buffer
			zero
			EXIT
		THEN

		\ the default is tos zero
		zero %tos !
		\ code(--
		\ if redirect was for tos then determine
		DUP ICC_TOSHRD = SWAP ICC_TOSNRD = IF
			\ extract tos from returned datagram and set tos
			%ipdata @ ic_data + _ip>ip_tos %tos !
		THEN
		\ (--
		\ get route entry.
		\ Remember the data portion of the redirect message
		\ contains the original datagram.
		%ipdata @ ic_data + _ip_route_get %route_entry !
		\ if _ip_route_get returns 0 the route has gone.
		%route_entry @ not IF
			\ no can do, no route in table for destination in any form
			\ nothing to redirect.
			\ This is serious, as the default route at least should be returned.
			\ It is not for us to reason why.
			%pep @ kill_free_buffer
			EXIT
		THEN

		\ Unfortunatly the redirect doesn't come with nice things like expected metric
		\ and netmask mask. We need to extract that from the current routing record.
		\ The current routing record may be the one we used to send the packet, then
		\ again it may not be. We extract the destination address of the original datagram
		\ determine the route we would now use and then do some sanity checks.
		\ If it looks like the redirect may improve the situation we use it.

		\ Make sure redirect came from gateway we currently
		\ believe we would send the datagram to. This is a timing
		\ thing. Message may be old info, we may have received a better route since the datagram
		\ in question was sent.
		%pep @ [ ep_data ip_src + ]T LITERAL + @
		%route_entry @ rt_gw + @ <> IF
			%route_entry @ route_free
			%pep @ kill_free_buffer
			EXIT
		THEN

		\ stupidity check
		\ Did the data come from a interface we would have sent the original datagram on.
		\ Can happen if there are two connecting nets, or if someone is trying to get you to
		\ send the data to a different network. The latter is a serious problem.
		%pep @ ep_nif_received + @
		%route_entry @ rt_interface + @ <> IF
			%route_entry @ route_free
			%pep @ kill_free_buffer
			EXIT
		THEN

		\ route_add { variable %net
		\             variable %mask
		\             variable %gw
		\             variable %metric
		\             variable %tos
		\             variable %interface
		\             variable %ttl
		\             variable %how
		\             variable %broadcast ( -- $ )

		\ add the specific entry
		%ipdata @ [ ic_data ip_dst + ]T LITERAL + @   \ destination address
		ip_maskall                                    \ only use entry for this address
		%ipdata @ ic_gw + @                           \ gateway to redirect to
		%route_entry @ rt_metric + @  1-              \ the aim of the exercise
		                                              \ to reduce the metric by 1
		%tos @                                        \ tos of service offered
		%route_entry @ rt_interface + @               \ Interface to send outgoing data over
		IC_RDTTL                                      \ how long the route is to live
		RT_ICC_REDIRECT                               \ how the route was generated
		FALSE
		route_add


		%route_entry @ route_free
		%pep @ kill_free_buffer

		zero
		EXIT
	;



protocol class

	protected
		cell% instance_variable %%icmp_in_errors
		cell% instance_variable %%IcmpInErrors
		cell% instance_variable %%IcmpInMsgs
		cell% instance_variable %%IcmpInEchos
		cell% instance_variable %%icmp_option_error
                cell% instance_variable %%echo_responce_cnt
                cell% instance_variable %%echo_demux_cnt
	public
		m: ( --)
			this [parent] :construct

			zero %%IcmpInErrors !
			zero %%IcmpInMsgs   !
			zero %%IcmpInEchos  !

			IPT_ICMP   %%protocol_number !
		; overrides :construct

		\ called if the byte order has to be swaped for network
		\ transmission. This is done in the interface just prior
		\ to transmission. On reception it is done after the protocol
		\ demux, otherwise we would have to demux twice.
		m: ( pep --)
			DROP
			\ is required but not for coldfire
		; overrides :proto_host<>net


		</code> </pre>
		<pre> <code>
		| : icmp_error  ( pep -- )
			1 %%IcmpInErrors +!
			kill_free_buffer
		;

		\ Fix up the
		\ received datagram and send it on it's way.
		| : icmp_echo_responce { variable %pep -- }{
			variable %ipdata_in
			variable %ipdata_length
			variable %tos
			\ variable %old_id
			}
                        1 %%echo_responce_cnt +!
                        %pep @ ep_error + @ IF
				%pep @ kill_free_buffer
				EXIT
			THEN

			%pep @ ep_ipdata + @ %ipdata_in !

			\ when the header is setup the data length is lost
			\ so put it aside
			%pep @ _pep>ip_data_length  %ipdata_length !


			%pep @ DUP setup_pep_from_pep


			this  %pep @  ep_proto_obj  + !
			\ protocol type is lost when header is constructed
			IPT_ICMP %pep @ [ ep_data ip_proto + ]T LITERAL + B!

			\ move contents of datagram down if required
			\ remember options may be the same length or shorter
			%ipdata_in @ %pep @ ep_ipdata + @
			<> IF
				%ipdata_in @ %pep @ ep_ipdata + @ %ipdata_length @ MOVE
			THEN

			\ add the data length to the pep
			%ipdata_length @ %pep @ add_to_ip

			\ change type to echo responce
			ICT_ECHORP %pep @ ep_ipdata + @ ic_type + B!

			\ and send it on its way.
			%pep @ queue_ip
			restart_level
		;


		\ Fix up the
		\ received datagram and send it on it's way.
		\ COLDFORTH asks the gateway for the time.
		\ COLDFORTH can be the gateway so this has to
		\ be implemented.
		| : icmp_timestamp_responce { variable %pep -- }{
			variable %ipdata_in
			variable %ipdata_length
			variable %tos

			ic1_length
			DUP CONSTANT _#org_timestamp 4 +
			DUP CONSTANT _#rev_timestamp 4 +
			DUP CONSTANT _#trans_timestamp 4 +
			DUP CONSTANT _#message_length
			DROP

			}
			%pep @ ep_error + @ IF
				%pep @ kill_free_buffer
				EXIT
			THEN

			%pep @ ep_ipdata + @ %ipdata_in !


			\ when the header is setup the data length is lost
			\ so put it aside
			%pep @ _pep>ip_data_length  DUP %ipdata_length !

			\ if the received is not long enough we cannot send a reply
			_#message_length < IF
				%pep @ kill_free_buffer
				EXIT
			THEN

			%pep @ DUP setup_pep_from_pep

			this  %pep @  ep_proto_obj  + !

			\ protocol type is lost when header is constructed
			IPT_ICMP %pep @ [ ep_data ip_proto + ]T LITERAL + B!

			\ move contents of datagram down if required
			\ remember options may be the same length or shorter
			%ipdata_in @ %pep @ ep_ipdata + @
			<> IF
				%ipdata_in @ %pep @ ep_ipdata + @ %ipdata_length @ MOVE
			THEN

			\ add the data length to the pep
			%ipdata_length @ %pep @ add_to_ip

			\ change type to echo responce
			ICT_TIMERP  %pep @ ep_ipdata + @ ic_type + B!

			\ add the required timestamps
			\ Update fields that must be done
			@standard_ms DUP
			%pep @ ep_ipdata + @ _#rev_timestamp + !
			%pep @ ep_ipdata + @ _#trans_timestamp + !

			\ and send it on its way.
			%pep @ queue_ip
			restart_level
		;



	\ table of error messages for the different codes
	\ we use named strings so the used can use the abort
	\ string to initiate recovery action.
	| CREATE $net_unreached    ," network unreachable"
	| CREATE $dest_unreached	 ," host unreachable"
	| CREATE $proto_unreached  ," protocol unreachable"
	| CREATE $port_unreached   ," port unreachable"
	| CREATE $frag_needed      ," require fragmentation"
	| CREATE $src_route_fail   ," source route failed"
	| CREATE $net_unknown      ," network unknown"
	| CREATE $host_unknown     ," host unknown"
	| CREATE $host_isolated    ," host isolated"
	| CREATE $net_prohibited   ," network access prohibited"
	| CREATE $host_prohibited  ," host access prohibited"
	| CREATE $net_tos_prob     ," network type of service problems"
	| CREATE $host_tos_prob     ," host type of service problems"
	| CREATE $host_out_range    ," Unknown error returned by destination"

	CREATE unreached_error_strings
		$net_unreached    t,
		$dest_unreached	  t,
		$proto_unreached  t,
		$port_unreached   t,
		$frag_needed      t,
		$src_route_fail   t,
		$net_unknown      t,
		$host_unknown     t,
		$host_isolated    t,
		$net_prohibited   t,
		$host_prohibited  t,
		$net_tos_prob     t,
		$host_tos_prob    t,
		$host_out_range   t,

	| #13 CONSTANT _#max_error_code

	| : icmp_dest_unreached { variable %pep }{
		variable %ipdata }
		%pep @ ep_ipdata + @ %ipdata !
		%pep @ ep_ipcount + @ ic_data -
		IPMHLEN
		< IF    \ >
			\ not enough of the datagram was returned
			%pep @ kill_free_buffer
			EXIT
		THEN
		\ address of error string
		%ipdata @ ic_code + B@ _#max_error_code MIN CELLS
		unreached_error_strings + @
		%pep @ ep_error + !

		\ protocol that caused error.
		%ipdata @ ic_data + ip_proto + B@
		proto_find ?DUP IF
                        \ object(--
			\ we have the protocol
			%pep @ SWAP :proto_error
			EXIT
		THEN
		\ get to here and we can't find protocol that generated original
		\ packet. This is give up time.
		\ (--
		%pep @ kill_free_buffer
	;

	\ table of error messages for the different codes
	\ we use named strings so the used can use the about
	\ string to initiate recovery action.
	| CREATE $transit_timeout  ," Time exceeded in transit"
	| CREATE $defrag_timeout	 ," Defrag timeout"
	| CREATE $unknown_timeout  ," Unknown timeout message"

	| CREATE timeout_error_strings
		$transit_timeout t,
		$defrag_timeout	 t,
		$unknown_timeout t,


	| #2 CONSTANT _#max_timeout_code

	| : icmp_timeout { variable %pep }{
		variable %ipdata }
		%pep @ ep_ipdata + @ %ipdata !
		%pep @ ep_ipcount + @ ic_data -
		IPMHLEN
		< IF    \ >
			\ not enough of the datagram was returned
			%pep @ kill_free_buffer
			EXIT
		THEN
		\ address of error string
		%ipdata @ ic_code + B@ _#max_timeout_code MIN CELLS
		timeout_error_strings + @
		%pep @ ep_error + !

		\ protocol that caused error.
		%ipdata @ ic_data + ip_proto + B@
		proto_find ?DUP IF
			\ we have the protocol
			%pep @ SWAP :proto_error
			EXIT
		THEN
		\ get to here and we can't find protocol that generated original
		\ packet. This is give up time.
		\ (--
		%pep @ kill_free_buffer
	;
	</code> </pre>
<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1700.html">RFC1700 page 69</a><br>
<pre>
       Codes
            0  Pointer indicates the error
            1  Missing a Required Option        [RFC1108]
            2  Bad Length
</pre>
	<pre> <code>
	\ table of error messages for the different codes
	\ we use named strings so the used can use the abort
	\ string to initiate recovery action.
	\ It is difficult to get the pointer value and it
	\ probable not worth making it available.
	| CREATE $param_problem  ," Parameter problem"
	| CREATE $param_missing  ," missing a required option"
	| CREATE $param_bad_length   ," Bad length"
	| CREATE $param_unknown  ," Unknown parameter problem code"

	| CREATE parameter_error_strings
		$param_problem t,
		$param_missing t,
		$param_bad_length t,
		$param_unknown t,


	| #3 CONSTANT _#max_parameter_code

	| : icmp_parameter { variable %pep }{
		variable %ipdata }
		%pep @ ep_ipdata + @ %ipdata !
		%pep @ ep_ipcount + @ ic_data -
		IPMHLEN
		< IF \ >
			\ not enough of the datagram was returned
			%pep @ kill_free_buffer
			EXIT
		THEN
		\ address of error string
		%ipdata @ ic_code + B@ _#max_parameter_code MIN CELLS
		parameter_error_strings + @
		%pep @ ep_error + !

		\ protocol that caused error.
		%ipdata @ ic_data + ip_proto + B@
		proto_find ?DUP IF
			\ we have the protocol
			%pep @ SWAP :proto_error
			EXIT
		THEN
		\ get to here and we can't find protocol that generated original
		\ packet. This is give up time.
		\ (--
		%pep @ kill_free_buffer
	;
	</code> </pre>
<h3>Echo</h3>
<p>
Echo reply demux. The demux is done on the message id. You have to open a echo_client
to ping a machine.
</p>
<p>
The more lists the faster the demux, the more memory you use.
Set as desired.
</p>
	<pre> <code>
	| ram_variable _%echo_last_identifier
	\ we don't expect many open echo clients
	| $2 CONSTANT _#echo_head_num
	| ram_variable _%echo_table _#echo_head_num CELLS ram_allot
	</code> </pre>
<p>
_echo_find and _echo_release will be used in the protocol object.
_echo_add and _echo_close will be used in the io_common object for
open and close.
</p>
	<pre> <code>
	| : _echo_find ( identifier --addr|zero)
		_%echo_table _#echo_head_num demux_find
	;

	| : _echo_add ( object identifier -- $|0 )
		_%echo_table _#echo_head_num  demux_add
	;

	| : _echo_release ( addr --)
		demux_release
	;

	| : _echo_remove ( identifier --)
		_%echo_table _#echo_head_num demux_remove
	;
	</code> </pre>
<p>
Because each conversation has an identifier, we do not have to look at the source
machine when demuxing echo responces. This speeds up the demux.
</p>
	<pre> <code>
	| : _echo_identifier ( object -- identifier )
		_%echo_last_identifier @
		$0FFFF AND
		\ if two tasks are trying at the same time
		\ one will get in first and the other will keep
		\ going.
		BEGIN
			2DUP _echo_add
		WHILE
			1+
			$0FFFF AND
		REPEAT
		NIP
		\ when we store the up to port we must make sure
		\ the task with the highest used port wins.
		_lock_word
		DUP _%udp_last_port @ 2DUP - ABS $07FFF > IF
			\ wrapped around
			MIN
		ELSE
			MAX
		THEN
		_%echo_last_identifier !
		_unlock_word
	;


	\ if your going to do it; you may as well do it properly.
	\ ping opens a echo_client; we have to take the reply
	\ and demux to the opened client.
	| : icmp_echo_demux ( pep -- )
		1 %%echo_demux_cnt +!
		DUP ep_ipdata + @ ic_id + W@
		\ pep id(--
		_echo_find DUP IF
			\ pep table(--
			\ this is a method in io_common
			TUCK _#demux_bucket_object + @ :consume_port
			_echo_release
			EXIT
		THEN
		\ pep zero(--
		\ don't send an error message the server is not interested.
		DROP
		kill_free_buffer
	;
		</code> </pre>
<h3>Timestamp</h3>
<p>
timestamp reply demux. The demux is done on the message id.
You have to open a icmp_timestamp object
to get a remote machines timestamp
</p>
<p>
The more lists the faster the demux, the more memory you use.
Set as desired.
</p>
	<pre> <code>
	| ram_variable _%timestamp_last_identifier
	\ we don't expect many open echo clients
	| $2 CONSTANT _#timestamp_head_num
	| ram_variable _%timestamp_table _#timestamp_head_num CELLS ram_allot
	</code> </pre>
<p>
_timestamp_find and _timestamp_release will be used in the protocol object.
_timestamp_add and _timestamp_close will be used in the io_common object for
open and close.
</p>
	<pre> <code>
	| : _timestamp_find ( identifier --addr|zero)
		_%timestamp_table _#timestamp_head_num demux_find
	;

	| : _timestamp_add ( object identifier -- $|0 )
		_%timestamp_table _#timestamp_head_num  demux_add
	;

	| : _timestamp_release ( addr --)
		demux_release
	;

	| : _timestamp_remove ( identifier --)
		_%timestamp_table _#timestamp_head_num demux_remove
	;
	</code> </pre>
<p>
Because each conversation has an identifier, we do not have to look at the source
machine when demuxing timestamp responces. This speeds up the demux.
</p>
	<pre> <code>
	| : _timestamp_identifier ( object -- identifier )
		_%timestamp_last_identifier @
		$0FFFF AND
		\ if two tasks are trying at the same time
		\ one will get in first and the other will keep
		\ going.
		BEGIN
			2DUP _timestamp_add
		WHILE
			1+
			$0FFFF AND
		REPEAT
		NIP
		\ when we store the up to port we must make sure
		\ the task with the highest used port wins.
		_lock_word
		DUP _%udp_last_port @ 2DUP - ABS $07FFF > IF
			\ wrapped around
			MIN
		ELSE
			MAX
		THEN
		_%timestamp_last_identifier !
		_unlock_word
	;


	\ if your going to do it; you may as well do it properly.
	\ timestamp opens a icmp_timestamp; we have to take the reply
	\ and demux to the opened client.
	| ram_variable %timestamp_demux_cnt
	| : icmp_timestamp_demux ( pep -- )
		1 %timestamp_demux_cnt +!
		DUP ep_ipdata + @ ic_id + W@
		\ pep id(--
		_timestamp_find DUP IF
			\ pep table(--
			\ this is a method in io_common
			TUCK _#demux_bucket_object + @ :consume_port
			_timestamp_release
			EXIT
		THEN
		\ pep zero(--
		\ don't send an error message the server is not interested.
		DROP
		kill_free_buffer
	;

	</code> </pre>

	<a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1700.html">RFC1700 page 67</a>
<pre>
Type    Name                                    Reference
----    -------------------------               ---------
  0     Echo Reply                               [RFC792]
  1     Unassigned                                  [JBP]
  2     Unassigned                                  [JBP]
  3     Destination Unreachable                  [RFC792]
  4     Source Quench                            [RFC792]
  5     Redirect                                 [RFC792]
  6     Alternate Host Address                      [JBP]
  7     Unassigned                                  [JBP]
  8     Echo                                     [RFC792]
  9     Router Advertisement                    [RFC1256]
 10     Router Selection                        [RFC1256]
 11     Time Exceeded                            [RFC792]
 12     Parameter Problem                        [RFC792]
 13     Timestamp                                [RFC792]
 14     Timestamp Reply                          [RFC792]
 15     Information Request                      [RFC792]
 16     Information Reply                        [RFC792]
 17     Address Mask Request                     [RFC950]
 18     Address Mask Reply                       [RFC950]
 19     Reserved (for Security)                    [Solo]
 20-29  Reserved (for Robustness Experiment)        [ZSu]
 30     Traceroute                              [RFC1393]
 31     Datagram Conversion Error               [RFC1475]
 32     Mobile Host Redirect              [David Johnson]
 33     IPv6 Where-Are-You                 [Bill Simpson]
 34     IPv6 I-Am-Here                     [Bill Simpson]
 35     Mobile Registration Request        [Bill Simpson]
 36     Mobile Registration Reply          [Bill Simpson]
 37-255 Reserved                                    [JBP]
</pre>
	<pre> <code>
		\ There has to be an entry in this table for every ICMP error type up to mask reply.
	| CREATE _ict_type_vectors
			' icmp_echo_demux      t, \ 0 ICT_ECHORP	\ Echo reply
			' icmp_error    t, \ 1 spare
			' icmp_error    t, \ 2 spare
			' icmp_dest_unreached  t, ( icmp_destur )   \ 3 ICT_DESTUR	   \ Destination unreachable
			' icmp_error    t, ( icmp_srcq   )   \ 4 ICT_SRCQ	   \ Source quench
			' icmp_redirect t, \ 5 ICT_REDIRECT  \ Redirect message type
			' icmp_error    t, \ 6 spare
			' icmp_error    t, \ 7 spare
			' icmp_echo_responce   t, \ 8 ICT_ECHORQ    \ Echo request
			' icmp_error    t, \ 9 spare
			' icmp_error    t, \ 10
			' icmp_timeout  t, ( icmp_timex  )   \ 11 ICT_TIMEX    \ Time exceeded
			' icmp_parameter  t, ( icmp_paramp )   \ 12 ICT_PARAMP   \ Parameter Problem
			' icmp_timestamp_responce t,  ( icmp_timerq )   \ 13 ICT_TIMERQ   \ Timestamp request
			' icmp_timestamp_demux      t, ( icmp_timerp )   \ 14 ICT_TIMERP   \ Timestamp reply
			\ <a HREF="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc1122.html">rfc1122</a>
			\ says Information request/reply is not the way to go.
			' icmp_error    t, \ 15 ICT_INFORQ   \ Information request
			' icmp_error    t, \ 16 ICT_INFORP   \ Information reply

			' icmp_error    t, ( icmp_maskrq )   \ 17 ICT_MASKRQ   \ Mask request
			' icmp_error    t, ( icmp_maskrp )   \ 18 ICT_MASKRP   \ Mask reply
			' icmp_error    t, \ 19 ICT_MAX_TYPE, must always point to error

	ICT_MAX_TYPE #20 ??<  \ > make sure table is long enough

		\ used by the proto task to get rid of the packet.
		m: { ( pep -- ) }{
			variable %ipdata }
			\ ### temp
			DUP ep_ipdata + @ %ipdata !
			%ipdata @ OVER ep_ipcount + @ cksum IF
				1 %%IcmpInErrors +!
				kill_free_buffer
				EXIT
			THEN
			1 %%IcmpInMsgs +!
			%ipdata @ ic_type + B@
			zero MAX ICT_MAX_TYPE MIN CELLS
			\ pep offset(--
			_ict_type_vectors + @execute
		; overrides :proto_demux

		\ this will be used by negative responces to echo requests,
		\ mask requests, and timestamp requests.
		m: { variable %pep -- }{
			variable %ipdata
			variable %returned_ipdata }
			%pep @ ep_ipdata + @ %ipdata !
			%ipdata @ ic_data + _ip>ip_hlen %ipdata @ ic_data + OVER +
			%returned_ipdata !
			\ header_length_returned_datagram(--
			%pep @ ep_ipcount + @ ic_data - SWAP - ic_data < IF  \ >
				\ (--
				\ didn't return icmp header
				%pep @ kill_free_buffer
				EXIT
			THEN
			\ lets deal with the echo first
			%returned_ipdata @ ic_type + B@ ICT_ECHORQ = IF
				%returned_ipdata @ ic_id + W@ _echo_find ?DUP IF
					\ table(--
					\ this is a method in io_common
					%pep @ OVER _#demux_bucket_object + @ :consume_port
					_echo_release
					EXIT
				THEN
			THEN
			\ ##### still have to do mask request.
			\ and timestamp request.
			\ get here and there is nowhere for error to go
			\ give up
			%pep @ kill_free_buffer
		; overrides :proto_error


		\ interface calls this to checksum the protocol; some protocols
		\ need info gained in the ip layer to generate correct checksum
		\ icmp isn't one of them; but we use a consistant path.
		m: { ( pep --) }{
			variable %ipdata }
			DUP ep_ipdata + @ %ipdata !
			zero %ipdata @ ic_cksum + W!
			%ipdata @ SWAP ep_ipcount + @ cksum
			%ipdata @ ic_cksum + W!
		; overrides :proto_checksum

		\ tell the world about ourselves
		m: ( offset --)
			CR DUP SPACES ." icmp_protocol | " ." Object: " this .h
			              ." protocol_number: " %%protocol_number @ .h
                        CR DUP SPACES ." Icmpinmsgs:  "  %%IcmpInMsgs @ .h
                                      ." IcmpInErrors: " %%IcmpInErrors @ .h
                        CR DUP SPACES ." Echo Responce: " %%echo_responce_cnt @ .h
                                      ." Exho demux: " %%echo_demux_cnt @ .h
			DROP
                        send
                ; overrides :print

end_class icmp_protocol
		</code> </pre>

</body>
</html>
