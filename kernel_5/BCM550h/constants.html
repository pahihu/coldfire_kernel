<html>
<head>
<title>COLDFORTH KERNEL</title>
<META NAME="Author" CONTENT="Charles Esson">
<META NAME="keywords" CONTENT="forth"> 
<META NAME="description" CONTENT=" COLDFORTH uses this file to generate COLDFORTH">
<LINK REL=stylesheet HREF="forth.css" TYPE="text/css">
</head>

<body>
<a HREF="./license.html">license</a>
<p>
Base for baud rate and timer calculations.
</p>
	<pre> <code>
	#45000000 CONSTANT _#bus_clock
	</code> </pre>
<h3>BCM550 Memory map</h3>
<p>
Very early in the startup routine we test the dynamic ram. To have this happen in a 
resonable time the boot prom needs to be cached. The minimum cache size is 16 meg. So 
the boot prom is mapped into a 16 meg region at the start of memory. The rest of the 
memory areas follow from there.
</p>
<table>
<tr><th>From</th>       <th>To</th>       <th>Size</th>     <th>Comment</th></tr>
<tr><td>0x00000000</td>  <td>0x07FFFF</td> <td>0x80000</td>  <td>Boot prom</td></tr> 
<tr><td>0x01000000</td>  <td>0x1FFFFF</td> <td>0x200000</td> <td>Application flash</td></tr> 
<tr><td>0x02400000</td>  <td>0x00FFFF</td> <td>0x4000</td>   <td>dual port memory</td></tr>
<tr><td>0x02600000</td>  <td>0x00FFFF</td> <td>0x10000</td>  <td>Ethernet Controller</td></tr>
<tr><td>0x02800000</td>  <td>0x00FFFF</td> <td>0x00400</td>  <td>Remote i/o</td></tr>
<tr><td>0x02A00000</td>  <td>0x0FFFFF</td> <td>0100000</td>  <td>RTI Bus</td></tr>
<tr><td>0x02C00000</td>  <td>0x07FFFF</td> <td>0x80000</td>  <td>Copy boot flash</td></tr>
<tr><td>0x02E00000</td>  <td>0x00FFFF</td> <td>0x10000</td>  <td>function see additional table</td></tr>
<tr><td>0x03000000</td>  <td>0x0F00FFF</td><td>0x1000</td>   <td>Modules base address register, any 4kbyte boundry</td></tr> 
<tr><td>0x03080000</td>  <td>0x0F00FFF</td><td>0x1000</td>   <td>Internal ram</td></tr>
<tr><td>0x10000000</td><td>0x10FFFFFF</td><td>0x1000000</td><td>DRAM1</td></tr> 
<tr><td>0x11000000</td><td>0x11FFFFFF</td><td>0x1000000</td><td>DRAM2</td></tr> 
</table>
<h4>Chip select 0, boot flash</h4>
	<pre> <code>
	.S .( start MCF5307_constants.html)
	$00000000 CONSTANT _#boot_flash_base
	$00080000 CONSTANT _#boot_flash_size
	</code> </pre>
<h4>Chip select 1, application flash</h4>
	<pre> <code>
	$01000000 CONSTANT _#application_flash_base
	$00200000 CONSTANT _#application_flash_size
	</code> </pre>
<h4>Chip select 2 -> 7</h4>
	<pre> <code>
	$02000000 CONSTANT _#csbar  \ chip select base address register value
	</code> </pre>
<h4>Chip select 2, RTI1000 dual port memory</h4>
	<pre> <code>
	$00400000 _#csbar + CONSTANT _#RTI1000_dual_port_base
	$00004000           CONSTANT _#RTI1000_dual_port_size
	</code> </pre>
<h4>Chip select 3, Ethernet controller</h4>
	<pre> <code>
	$00600000 _#csbar + CONSTANT _#ethernet_controller_base
	$00010000           CONSTANT _#ethernet_controller_size
	</code> </pre>
<h4>Chip select 4, Remote IO</h4>
	<pre> <code>
	$00800000 _#csbar + CONSTANT _#remote_i/o_base
	$00000400           CONSTANT _#remote_i/o_size
	</code> </pre>
<h4>Chip select 5, RTI1000 bus</h4>
	<pre> <code>
	$00A00000 _#csbar + CONSTANT _#RTI1000_bus_base
	$00100000           CONSTANT _#RTI1000_bus_size
	</code> </pre>
<h4>Chip select 6, Boot copy flash</h4>
	<pre> <code>
	$00C00000 _#csbar + CONSTANT _#copy_boot_flash_base
	$00080000           CONSTANT _#copy_boot_flash_size
	</code> </pre>
<h4>Chip select 7, function data</h4>
	<pre> <code>
	$00E00000 _#csbar + CONSTANT _#function_data_base
	$00000040           CONSTANT _#function_data_size
	</code> </pre>
<h4>Dynamic memory</h4>
	<pre> <code>
	_prom_kernel_start CONSTANT _#sdram0_base
	$01000000 CONSTANT _#sdram0_size 
	$11000000 CONSTANT _#sdram1_base
	$01000000 CONSTANT _#sdram1_size

	_#sdram0_base CONSTANT _#start_dynamic
	$12000000 CONSTANT _#end_dynamic	
.S .( after _#end_dynamic)  
	</code> </pre>
<h3>MBAR</h3>
<p>
MBAR ( Module Base Address Register) is set with the code:
</p>
<pre> <samp>
#mba _#mbar_valid_bit + #  D0   MOV
D0      MBAR MOV
</samp> </pre>
<p>
Once the MBA is set the registers are located in a specific 
spot in memory.
</p>
	<pre> <code>
	$03000000 CONSTANT #mba
		\ set to zero on a reset, must be set to one for access
		\ to system integration module
		$00000001 CONSTANT _#mbar_valid_bit

		\ every address has an address modifier associated 
		\ with it. Setting the following bits [revent access
		\ to the system modules in particular address spaces.
		\ In this sytem access is allowed in all spaces.
		$00000002 CONSTANT _#mbar_block_user_data
		$00000004 CONSTANT _#mbar_block_user_code
		$00000008 CONSTANT _#mbar_block_system_data
		$00000010 CONSTANT _#mbar_block_system_code
		$00000020 CONSTANT _#mbar_block_c/i
		$00000040 CONSTANT _#mbar_allow_alternate
	</code> </pre> 

<h3>RAMBAR</h3>
<p>
Base address of the on board static ram. Set with the instruction:<br>
<pre> <samp>
D0 RAMBAR MOV
</samp> </pre>
<p>
Section 6.3.4 talks about reducing power consumption, in our case the on board ram
is not used for code so we block code accesses
	<pre> <code>
	$03080000           CONSTANT _#rambar_base     \ coldfire ram
		$00000001 CONSTANT _#rambar_valid
		$00000002 CONSTANT _#rambar_block_user_data
		$00000004 CONSTANT _#rambar_block_user_code
		$00000008 CONSTANT _#rambar_block_system_data
		$00000010 CONSTANT _#rambar_block_system_code
		$00000020 CONSTANT _#rambar_block_c/i
		$00000100 CONSTANT _#rambar_write_protect

	$1000 CONSTANT _#rambar_size
	</code> </pre>
<h3>CACHE</h3>
<p>
The memory space can be divided up into three modes. This system has
a lot of memory areas devoted to I/O, the default mode shall be suitable
for that type of operation. That is non-cachable. Imprecise is the default
mode. If a location access resets an interrupt it must be written to. Read
imprecise mode allows multiple reads under some circumstances. 
Oh how I wish for the simple days, when computers did what they where told.
</p>
<h4>CACR ( Cache Control register) </h4>
	<pre> <code>
	$80000000 CONSTANT _#cacr_EC    \ Enable cache
\	$20000000 CONSTANT _#cacr_ESB   \ We don't enable the store buffer, there is no code
	                               \ in non cachable areas
\	$10000000 CONSTANT _#cacr_DPI   \ Disable CPUSHL invalidate. Don't use the instruction
	                               \ don't care
\	$08000000 CONSTANT _#cacr_HLCK  \ don't use.
	$01000000 CONSTANT _#cacr_CINVA \ cache invalidate all, needed to get started
\	$00000400 CONSTANT _#cacr_DNFB  \ All code is cached
	$00000300 CONSTANT _#cacr_DCM   \ Default cache mode, cache-inhibited,imprecise 
\	$00000001 CONSTANT _#cacr_DW    \ write is allowed
	</code> </pre>	
<h4>ACR0</h4>
	<pre> <code>
	_#sdram0_base CONSTANT _#acr0_address_base
	_#sdram0_size 1 - $FF000000 AND 8 RSHIFT CONSTANT _#acr0_address_mask \ will be zero
	$8000  CONSTANT _#acr0_enable
	$6000  CONSTANT _#acr0_SFIELD \ ignore FC2 when matching
	$0020  CONSTANT _#acr0_CM     \ cachable, copyback
	</code> </pre>
<h4>ACR1</h4>
	<pre> <code>
	_#boot_flash_base CONSTANT _#acr1_address_base
	_#boot_flash_size 1 - $FF000000 AND 8 RSHIFT CONSTANT _#acr1_address_mask \ will be zero
	$8000  CONSTANT _#acr1_enable
	$6000  CONSTANT _#acr1_SFIELD \ ignore FC2 when matching
	$0020  CONSTANT _#acr1_CM     \ cachable, copyback
	</code> </pre>
<h3>System integration module</h3>
<p>
Describe the 5307 memory map in byte offsets. Names are taken 
from the 5307 users manual, but are preceeded with a size code.<br>
b = byte<br>
w = word<br>
l = long<br> 
</p>
<p> See section 8 of the users manual</p>
<h4>reset status register</h4>
<p>
Read only register. Read if you want to find out reset reason.
</p>
	<pre> <code>
	$000	#mba + CONSTANT _breg_RSR
		$80 CONSTANT _#rst_hard_reset
		$20 CONSTANT _#rst_soft_reset
	</code> </pre>
<h4>System protection control register</h4>
	<pre> <code>
	$001 #mba + CONSTANT _breg_SYPCR
		\ ### set to $80 when cards with new mask arrive
		$00 CONSTANT _#sypcr_watchdog_enable
		$40 CONSTANT _#sypcr_timeout_enable_reset
		$20 CONSTANT _#sypcr_prescale \ clock divided by 8192
		\ prescale = 0
		\ 00 = 2**9 01 = 2**11 10 = 2**13 11 = 2**15
		\ prescale = 1
		\ 00 = 2**22 01 = 2**24 10 = 2**26 ( aprox 1 sec) 11 = 2**28 ( aprox 4 sec)
		$18 CONSTANT _#sypcr_swt



	\ software watchdog interrupt vector register
	$002 #mba + CONSTANT _breg_SWIVR
	\ Software watchdog service register
	$003 #mba + CONSTANT _breg_SWSR
	\ Pin assignment register
	\ see section 10 of the users manual see also
	\ _wreg_PADDR and _wreg_PADAT
	$004 #mba + CONSTANT _wreg_PAR
	\ Interrupt assignment register
	$006 #mba + CONSTANT _breg_IRQPAR
	\ PLL control register
	$008 #mba + CONSTANT _breg_PLLCR
		$80 CONSTANT _#pllcr_ENBSTOP  \ enable stop
		07 4 LSHIFT  CONSTANT _#pllcr_PLLIPL 
	\ master bus control register
	$00C #mba + CONSTANT _breg_MPARP
		$20 CONSTANT _#mpark_IARBCTRL
		$10 CONSTANT _#mpark_EARBCTRL
		$08 CONSTANT _#mpark_SHOWDATA
	</code> </pre>
<h4>Interrupt controller</h4>
<p>
See section 8.3.3 of the user manual
</p>
<table>
<caption><b>Interrupt source</b></caption>
<tr><th>source</th>  <th>AVEC</th><th>Level</th><th>IP</th><th>Vector</th><th>comment</th></tr>
<tr><td>SWT</td>     <td>0</td>   <td>7(1)</td> <td>00</td><td>40    </td><td>       </td></tr>
<tr><td>Timer 1</td> <td>1</td>   <td>6(2)</td> <td>00</td><td>1E    </td><td>10 msec</td></tr>
<tr><td>Timer 2</td> <td>1</td>   <td>5(3)</td> <td>11</td><td>1D    </td><td>Watchdog</td></tr>
<tr><td>MBUS</td>    <td>1</td>   <td>4(5)</td> <td>11</td><td>1C    </td><td>Not used</td></tr>
<tr><td>UART1</td>   <td>0</td>   <td>6(4)</td> <td>11</td><td>60    </td><td>       </td></tr>
<tr><td>UART2</td>   <td>0</td>   <td>6</td>    <td>10</td><td>61    </td><td>       </td></tr>
<tr><td>DMA0</td>    <td>0</td>   <td>2</td>    <td>11</td><td>62    </td><td>Ethernet</td></tr>
<tr><td>DMA1</td>    <td>0</td>   <td>2</td>    <td>10</td><td>63    </td><td>User   </td></tr>
<tr><td>DMA2</td>    <td>0</td>   <td>2</td>    <td>01</td><td>64    </td><td>Uart0</td></tr>
<tr><td>DMA3</td>    <td>0</td>   <td>2</td>    <td>00</td><td>65    </td><td>Uart1</td></tr>
<tr><td>reserved</td><td>1</td>   <td>3</td>    <td>10</td><td>1B    </td><td>       </td></tr>
<tr><td>reserved</td><td>1</td>   <td>3</td>    <td>01</td><td>1B    </td><td>       </td></tr>
<tr><td>EINT7</td>   <td>1</td>   <td>7(1)</td> <td>- </td><td>1F    </td><td>Bus error</td></tr>
<tr><td>EINT6</td><td>-</td>      <td>-</td>    <td>- </td><td>-     </td><td></td></tr>
<tr><td>EINT5</td><td>0</td>      <td>5</td>    <td>- </td><td>80->8F</td><td>RTI1000 bus</td></tr>
<tr><td>EINT4</td><td>-</td>      <td>-</td>    <td>- </td><td>-     </td><td>       </td></tr>
<tr><td>EINT3-a</td><td>0</td>    <td>3(6)</td> <td>- </td><td>90    </td><td>Digital1</td></tr>
<tr><td>EINT3-b</td><td>"</td>    <td>"</td>    <td>- </td><td>91    </td><td>Digital2</td></tr>
<tr><td>EINT3-c</td><td>"</td>    <td>"</td>    <td>- </td><td>92    </td><td>RTI-Aclow</td></tr>
<tr><td>EINT3-d</td><td>"</td>    <td>"</td>    <td>- </td><td>93    </td><td>RTI-Sysfail</td></tr>
<tr><td>EINT3-e</td><td>"</td>    <td>"</td>    <td>- </td><td>94    </td><td>Remote_I/O</td></tr>
<tr><td>EINT2</td><td>0</td>      <td>-</td>    <td>- </td><td>-     </td><td>       </td></tr>
<tr><td>EINT1</td><td>1</td>      <td>1</td>    <td>- </td><td>19    </td><td>ethernet</td></tr>
<tr><td></td>
</table>
(1)SWT doesn't work, buss error is generated by card. Both have to be on level 7. SWT is vectored, external bus error is autovectored<br>
(2)Multitasker still has clock tasks at lowest priority. Clock interrupt routine can be
on any level. We put it on highest so 10msec interrupts are not lost.<br>
(3)Placed on level 5 as the external inturrupt vectors leaving the auto vector free for the second timer.<br>
(4)All level 6 interrupts are vectored.
(5)MBUS only autovectored.
(6)Level three used for system interrups, autovector not used.

<h4>Interrupt pending register</h4>
<p>
A read only register
</p>
	<pre> <code>
	$040 #mba + CONSTANT _lreg_IPR
	</code> </pre>
<h4>Interrupt mask register</h4>
<p>
You set a bit to disable the interrupt.
</p>

	<pre> <code>
	$044 #mba + CONSTANT _lreg_IMR
		$20000 CONSTANT _#imr_DMA3
		$10000 CONSTANT _#imr_DMA2
		$08000 CONSTANT _#imr_DMA1
		$04000 CONSTANT _#imr_DMA0
		$02000 CONSTANT _#imr_UART2
		$01000 CONSTANT _#imr_UART1
		$00800 CONSTANT _#imr_MBUS
		$00400 CONSTANT _#imr_TIMER2
		$00200 CONSTANT _#imr_TIMER1
		$00100 CONSTANT _#imr_SWT
		$00080 CONSTANT _#imr_EINT7
		$00040 CONSTANT _#imr_EINT6
		$00020 CONSTANT _#imr_EINT5
		$00010 CONSTANT _#imr_EINT4
		$00008 CONSTANT _#imr_EINT3
		$00004 CONSTANT _#imr_EINT2
		$00002 CONSTANT _#imr_EINT1
	</code> </pre>

<h4>Autovector control_register</h4>
<p>
Set to true if the external interrupt is to be auto vectored. In our case external 
interrupt 1 has to be autovectored, all others are vectored. We don't need an external AS
on AVEC.
</p>

	<pre> <code>
	$04B #mba + CONSTANT _breg_AVCR
		$80 CONSTANT _#avec_AVEC7
		$40 CONSTANT _#avec_AVEC6
		$20 CONSTANT _#avec_AVEC5
		$10 CONSTANT _#avec_AVEC4
		$08 CONSTANT _#avec_AVEC3
		$04 CONSTANT _#avec_AVEC2
		$02 CONSTANT _#avec_AVEC1
		$01 CONSTANT _#avec_BLK
	</code> </pre>

<h4>Interrupt control register 0</h4>
<p>
SWT, not working at the moment.
See section 8.3.4
</p>

	<pre> <code>
	$04C #mba + CONSTANT _breg_ICR0
		$00 CONSTANT _#icr0_AVEC
		$07 2 LSHIFT CONSTANT _#icr0_IL
		$00 CONSTANT _#icr0_IP
	</code> </pre>

<h4>Interrupt control register 1</h4>
<p>
TIMER 1
</p>

	<pre> <code>
	$04D #mba + CONSTANT _breg_ICR1
		$80 CONSTANT _#icr1_AVEC
		$06 2 LSHIFT CONSTANT _#icr1_IL
		$03 CONSTANT _#icr1_IP
	</code> </pre>

<h4>Interrupt control register 2</h4>
<p>
TIMER 2
</p>

	<pre> <code>
	$04E #mba + CONSTANT _breg_ICR2
		$80 CONSTANT _#icr2_AVEC
		$05 2 LSHIFT CONSTANT _#icr2_IL
		$03 CONSTANT _#icr2_IP
	</code> </pre>

<h4>Interrupt control register 3</h4>
<p>
MBUS
</p>

	<pre> <code>
	$04F #mba + CONSTANT _breg_ICR3
		$00 CONSTANT _#icr3_AVEC
		$04 2 LSHIFT CONSTANT _#icr3_IL
		$03 CONSTANT _#icr3_IP
	</code> </pre>

<h4>Interrupt control register 4</h4>
<p>
Uart 1
</p>

	<pre> <code>
	$050 #mba + CONSTANT _breg_ICR4
		$00 CONSTANT _#icr4_AVEC
		$06 2 LSHIFT CONSTANT _#icr4_IL
		$00 CONSTANT _#icr4_IP
	</code> </pre>

<h4>Interrupt control register 5</h4>
<p>
Uart 2
</p>

	<pre> <code>
	$051 #mba + CONSTANT _breg_ICR5
		$00 CONSTANT _#icr5_AVEC
		$06 2 LSHIFT CONSTANT _#icr5_IL
		$03 CONSTANT _#icr5_IP
	</code> </pre>

<h4>Interrupt control register 6</h4>
<p>
DMA0
</p>

	<pre> <code>
	$052 #mba + CONSTANT _breg_ICR6
		$00 CONSTANT _#icr6_AVEC
		$02 2 LSHIFT CONSTANT _#icr6_IL
		$03 CONSTANT _#icr6_IP
	</code> </pre>

<h4>Interrupt control register 7</h4>
<p>
DMA1
</p>

	<pre> <code>
	$053 #mba + CONSTANT _breg_ICR7
		$00 CONSTANT _#icr7_AVEC
		$02 2 LSHIFT CONSTANT _#icr7_IL
		$02 CONSTANT _#icr7_IP
	</code> </pre>

<h4>Interrupt control register 8</h4>
<p>
DMA2
</p>

	<pre> <code>
	$054 #mba + CONSTANT _breg_ICR8
		$00 CONSTANT _#icr8_AVEC
		$02 2 LSHIFT CONSTANT _#icr8_IL
		$01 CONSTANT _#icr8_IP
	</code> </pre>

<h4>Interrupt control register 9</h4>
<p>
DMA3
</p>

	<pre> <code>
	\ Interrupt control register 9
	$055 #mba + CONSTANT _breg_ICR9
		$00 CONSTANT _#icr9_AVEC
		$02 2 LSHIFT CONSTANT _#icr9_IL
		$00 CONSTANT _#icr9_IP
	</code> </pre>

<h4>Interrupt control register 10</h4>
<p>
Reserved
</p>

	<pre> <code>
	\ Interrupt control register 10
	$056 #mba + CONSTANT _breg_ICR10
		$80 CONSTANT _#icr10_AVEC
		$03 2 LSHIFT CONSTANT _#icr10_IL
		$01 CONSTANT _#icr10_IP
	</code> </pre>

<h4>Interrupt control register 11</h4>
<p>
Reserved
</p>

	<pre> <code>
	\ Interrupt control register 11
	$057 #mba + CONSTANT _breg_ICR11
		$80 CONSTANT _#icr11_AVEC
		$03 2 LSHIFT CONSTANT _#icr11_IL
		$00 CONSTANT _#icr11_IP
	</code> </pre>

<h3>Chip select module</h3>
<p>See section 9 of the users manual</p>
<h4>CHIP-SELECT ADDRESS REGISTER (CSAR0, CSAR1 AND CSBAR)</h4>
<p> 
Each CSARx and CSBAR determines the base address of the corresponding chip-select pin.
CSAR0 and CSAR1 determine the base addresses from which chip-selects 0 and 1 will be
offset, respectively. CSBAR determines the base address from which chip-selects 2 through
7 will be offset.
</p>
<p>
CSAR0 and CSAR1 are 16-bit read/write registers.<br> 
CSBAR is a 8-bit read/write register.<br>
The value stored in each CSAR register corresponds to A[31:16]. The value stored in
the CSBAR register corresponds to A[31:24].<br>
CSAR0, CSAR1 and CSBAR are uninitialized by reset
</p>
	<pre> <code>
	\ Chip select address register bank0
	$080 #mba + CONSTANT _wreg_CSAR0
	</code> </pre>

<a name="CSMR0-7"></a>
<h4>Chip Select Mask Register ( CSMR0 -> CSMR7 )</h4>
<table>
<tr valign=top><th>Bit</th><th>Name</th><th>Comment</th></tr>
<tr valign=top><td>31->16</td><td> BAM - Base address mask</td>
<td>
This field defines the chip-select block size through the 
use of address mask bits. Any set bit masks the corresponding 
base address register (CSAR) bit (the base address bit becomes a 
don’t care in the decode).
0 = Corresponding address bit is used in chip select decode
1 = Corresponding address bit is a don’t care in chip select decode
</td></tr>
<tr valign=top><td>15->9</td><td>Reserved</td><td></td></tr>
<tr valign=top><td>8</td><td>WP - Write protect</td>
<td>The WP bit can restrict write accesses to the address range in a CSAR. 
An attempt to write to the range of addresses specified in a CSAR 
that has this bit set will result in the appropriate chip-select not being selected.
1 = Only read accesses are allowed
0 = Either read or write accesses are allowed
</td>
</tr>
<tr valign=top><td>6</td><td>AM - alternate master</td>
<td>
When AM=0 and an alternate master access occurs, SC, SD, UC, and UD are “don’t
cares” in the chip-select decode. 
</td></tr>
<tr valign=top><td>5</td><td>C/I = CPU space and Interrupt Acknowledge Cycle mask</td>
<td>
CS0, CS1, and CS7 only. Set to one to mask out.
</td></tr>
<tr valign=top><td>4</td><td>SC = Supervisor Code address space mask</td><td>Set to one to mask out.</td></tr>
<tr valign=top><td>3</td><td>SD = Supervisor Data address space mask</td><td>Set to one to mask out.</td></tr>
<tr valign=top><td>2</td><td>UC = User Code address space mask</td><td>Set to one to mask out.</td></tr>
<tr valign=top><td>1</td><td>UD = User Data address space mask</td><td>Set to one to mask out.</td></tr>
<tr valign=top><td>4</td><td>V - Valid bit</td><td>
The Valid bit indicates that the contents of its address register, 
mask register, and control register are valid. 
The programmed chip selects do not assert until the V-bit is set (except
for CS0 which acts as the global (boot) chip select.
</td></tr>
</table>
	
	<pre> <code>
	\ chip select mask register bank0
	$084 #mba + CONSTANT _lreg_CSMR0
		$00100 CONSTANT _#csmrx_WP  \ write protect
		$00040 CONSTANT _#csmrx_AM  \ alternate master
		$00020 CONSTANT _#csmrx_C/I \ No cpu/iack select 1,2 and 7
		$00010 CONSTANT _#csmrx_SC  \ supervisor code
		$00008 CONSTANT _#csmrx_SD  \ supervisor data
		$00004 CONSTANT _#csmrx_UC  \ User code
		$00002 CONSTANT _#csmrx_UD  \ User data
		$00001 CONSTANT _#csmrx_V   \ valid bit. 
	</code> </pre>

<a name="CSCR0-7"></a>
<h4>CHIP-SELECT CONTROL REGISTER (CSCR0 - CSCR7).</h4>
<p>
Each CSCR controls the auto acknowledge, external master support, port size, 
burst capability, and activation of each of the chip-selects.
</p>
<table>
<caption><b>Chip Select Control Register(CSCR0-7)</b> </caption>
<tr valign=top><th>Bit</th><th>Name</th><th>Comment</th></tr>

<tr valign=top><td>15,14</td><td>Reserved</td><td></td></tr>

<tr valign=top><td>13->10</td><td>WS - Wait States</td><td>
This field defines the number of wait states that will be 
inserted before an internal transfer acknowledge is generated. 
If the AA bit is set to 0, TA is asserted by the external system
regardless of the number of wait states generated. In that case the external transfer
acknowledge will end the cycle.
</td></tr>

<tr valign=top><td>8</td><td>AA - Auto-Acknowledge Enable</td>
<td>
This field controls the assertion of the internal transfer-acknowledge 
during all accesses that hit in the corresponding chip-select address space. 
If AA=1, the internal transfer-acknowledge will be asserted at 
the time determined by the value of WS[3:0]. If AA=0, the Chip-Select 
Module will not cause the internal transfer acknowledge to be asserted and the
cycle will have to be terminated by the external system.
</td></tr>

<tr valign=top><td>7,6</td><td>PS - Port Size</td><td>
This field specifies the width of the data associated with each chip-select. 
It determines where data will be driven during write cycles 
and where data will be sampled during read cycles.<br>
00 = 32-bit port size - Data sampled and driven on D[31:0]<br>
01 = 8-bit port size - Data sampled and driven on D[31:24] only<br>
10 = 16-bit port size - Data sampled and driven on D[31:16] only<br>
11 = 16-bit port size - Data sampled and driven on D[31:16] only<br>
</td></tr>

<tr valign=top><td>4</td><td>BSTR - Burst Read Enable</td> 
<td>
This field specifies the read burst capability of the memory 
associated with each chip- select. If BSTR=1, all reads from 
port sizes smaller than the requested transfer size will be bursted,
including longword reads from 8 and 16-bit ports, word reads from 
8-bit ports as well as line reads from 8-, 16-, and 32-bit ports. 
If BSTR=0, all reads from port sizes smaller than the
requested transfer size will be broken into individual reads 
that are no larger than the specified port size. For example, 
a longword read from an 8-bit port would be broken into
four individual byte reads. 0 = Break all reads that are larger 
than the specified port size into individual nonburst reads 
that are no larger than the specified port size
</td></tr>
<tr valign=top><td>3</td><td>BSTW - Burst Write Enable</td>
<td>
This field specifies the write burst capability of the 
memory associated with each chip-select.
If BSTW=1, all writes to port sizes smaller than 
the requested transfer size will be bursted,
including longword writes to 8 and 16-bit ports, 
word writes to 8-bit ports as well as line writes
to 8-, 16-, and 32-bit ports. If BSTW=0, all writes 
to port sizes smaller than the requested
transfer size will be broken into individual writes 
that are no larger than the specified port
size. For example, a longword write to an 8-bit port would 
be broken into four individual byte writes.
</td></tr>
<tr valign=top><td>3</td><td>BEM - Byte Enable Module</td>
<td>
This field specifies the mode of functionality for byte enables. 
Certain SRAMs have byte enables that must be asserted during reads 
(in addition to writes.) The BEM bit may be set in the relevant 
CSCR to provide the appropriate mode of byte enable in support of these
SRAMS. The default mode after reset is 0 for CS7 - CS1 and 1 for CS0.<br>
1 = BE/BWE signals generated for data reads and writes<br>
0 = BWE signals generated for data writes only<br>
</td></tr>
</table>
	<pre> <code>
	\ chip select control register bank0
	\ Boot flash
	$08A #mba + CONSTANT _wreg_CSCR0
		$2000 CONSTANT _#cscr0_wait_states \ eight wait states
		$0100 CONSTANT _#cscrx_AA   \ auto acknowledge
		$0040 CONSTANT _#cscr0_port_size   \ 8 bit
		$0020 CONSTANT _#cscrx_BEM  \ Byte enable module
		$0010 CONSTANT _#cscrx_BSTR \ Burst read enable
		$0008 CONSTANT _#cscrx_BSWE \ Burst write enable 

	\ Chip select address register bank1
	\ Application flash
	$08C #mba + CONSTANT _wreg_CSAR1
	\ chip select mask register bank1
	$090 #mba + CONSTANT _lreg_CSMR1
	\ chip select control register bank1
	$096 #mba + CONSTANT _wreg_CSCR1
		$1800 CONSTANT _#cscr1_wait_states \ six wait states
		$0080 CONSTANT _#cscr1_port_size \ 16 bit

	\ Chip select address register bank2
	\ RTI1000 dual port memeory
	$098 #mba + CONSTANT _wreg_CSAR2
	\ pre 00J20C mask
	$098 #mba + CONSTANT _breg_CSBAR
	\ chip select mask register bank2
	$09C #mba + CONSTANT _lreg_CSMR2
	\ chip select control register bank2
	$0A2 #mba + CONSTANT _wreg_CSCR2
		$0C00 CONSTANT _#cscr2_wait_states \ three wait states
		$0080 CONSTANT _#cscr2_port_size   \ 16 bit

	\ Chip select address register bank3
	\ Ethernet controller
	$0A4 #mba + CONSTANT _wreg_CSAR3
	\ chip select mask register bank3
	$0AA #mba + CONSTANT _wreg_CSMR3
	\ chip select control register bank3
	$0AE #mba + CONSTANT _wreg_CSCR3
			$0080 CONSTANT _#cscr3_port_size \ 16 bit


	\ Chip select address register bank4
	\ Remote I/O dual port memory
	$0B0 #mba + CONSTANT _wreg_CSAR4
	\ chip select mask register bank4
	$0B6 #mba + CONSTANT _wreg_CSMR4
	\ chip select control register bank4
	$0BA #mba + CONSTANT _wreg_CSCR4
		$1800 CONSTANT _#cscr4_wait_states \ six wait states
		$0040 CONSTANT _#cscr4_port_size \ 08 bit

	\ Chip select address register bank5
	\ RTI1000 bus
	\ Auto acknowledge is not used.
	$0BC #mba + CONSTANT _wreg_CSAR5
	\ chip select mask register bank5
	$0C2 #mba + CONSTANT _wreg_CSMR5
	\ chip select control register bank5
	$0C6 #mba + CONSTANT _wreg_CSCR5
		$0080 CONSTANT _#cscr5_port_size \ 16 bit

	\ Chip select address register bank6
	\ Boot copy flash
	$0C8 #mba + CONSTANT _wreg_CSAR6
	\ chip select mask register bank6
	$0CE #mba + CONSTANT _wreg_CSMR6
	\ chip select control register bank6
	$0D2 #mba + CONSTANT _wreg_CSCR6
		$1800 CONSTANT _#cscr6_wait_states \ six wait states
		$0040 CONSTANT _#cscr6_port_size \ 08 bit

	\ Chip select address register bank7
	\ System control registers.
	$0D4 #mba + CONSTANT _wreg_CSAR7
	\ chip select mask register bank7
	$0DA #mba + CONSTANT _wreg_CSMR7
	\ chip select control register bank7
	$0DE #mba + CONSTANT _wreg_CSCR7
		$0C00 CONSTANT _#cscr7_wait_states \ one wait states
		$0040 CONSTANT _#cscr7_port_size   \ 08 bit
.S .( after _#cscr7_port_size)
	</code> </pre>

<h3>DRAM controller</h3>
<p>See section 11 of the users manual</p>
<h4>Address mutiplexing</h4>
<table>
<caption>Address Muxing Scheme (32 bit)</caption>
<tr><th>Sdram Address Pin</th><th>Coldfire Address Pin</th><th>ROW ADDRESS</th><th>COLUMN ADDRESS</th><tr>
<tr><td></td><td>16</td><td>16</td><td>1</td></tr>
<tr><td>A0</td><td>15</td><td>15</td><td>2 used</td></tr>
<tr><td>A1</td><td>14</td><td>14</td><td>3 used</td></tr>
<tr><td>A2</td><td>13</td><td>13</td><td>4 used</td></tr>
<tr><td>A3</td><td>12</td><td>12</td><td>5 used</td></tr>
<tr><td>A4</td><td>11</td><td>11</td><td>6 used</td></tr>
<tr><td>A5</td><td>10</td><td>10</td><td>7 used</td></tr>
<tr><td>A6</td><td>9</td><td>9</td><td>8 used</td></tr>
<tr><td>A7</td><td>17</td><td>17</td><td>16 used</td></tr>
<tr><td>A8</td><td>18</td><td>18</td><td>17</td></tr>
<tr><td>A9</td><td>19</td><td>19</td><td>18</td></tr>
<tr><td>A11</td><td>20</td><td>20</td><td>19</td></tr>
<tr><td>A10(precharge command)</td><td>21</td><td>21</td><td>20</td></tr>
<tr><td>BA0</td><td>22</td><td>22</td><td>21</td></tr>
<tr><td>BA1</td><td>23</td><td>23</td><td>22</td></tr>
<tr><td></td><td>24</td><td>24</td><td>23</td></tr>
<tr><td></td><td>25</td><td>25</td><td>24</td></tr>
</table>
<p>
We are using two 1Meg*16*4 per bank.
</p>
<p>
Memory chips with a page size below 512 byts are not supported.
Chips with a page size greater than 512 bytes will have the page split up
and placed all over tha place.
</p>
<p>
In our arrangment each chip has a page size of 512 bytes but two are
used to give us a 32 bit wide data path resulting in a page size of 1024 bytes.
</p>
<p>
In our example the additional bit multiplexed with the column addess is address
bit 16. So the second half of the sdram memory page is found 64k away in the coldfire
memory map.
</p>
<p>
The generation of the required row address is the problem of the memory controller.
So the net effect is a few more row address generations when long data structures 
are being delt with.
</p>
<p>
We have a 32 bit data path, we therfore don't need address bits 0 and 1 in the
column address. Looking at the above table we need coldfire address pin 15 connected
to the sdram address pin 0, coldfire address pin 14 to sdram address pin 1 and so on
until address pin 9. This deal with address bits 2 to 15. Coldfire address pins 17 to 
21 are then connected to the sdram address pins 7 to 11, this deals with address bits
16 ( as part of the column address) to 21. 
Coldfire address pins 20 and 21 are used as the bank selects. 
</p>
<p>There is one small complication. In 32 bit mode coldfire address A21 has the 
precharge command on it, this must be connected to sdram adress pin 10.
<p>




<a name="DCR"></a>
<h4>DRAM control register ( DCR )</h4>

<table>
<tr><th>bit</th><th>name</th><th>Comment</th><th>BCM550</th></tr>
<tr valign=top><td>15</td><td>SO - Synchronous Operation</td>
<td>This bit determines if the SADRAMC is in synchronous operation mode. 
For synchronous DRAMs, this bit must be set to one. 
Note that once the part has entered into synchronous operation, 
it cannot be returned to asynchronous operation except by a reset. </td><td>1</td></tr>

<tr valign=top><td>14</tr><td></td><td>Reserved</td><td>0</td></tr>

<tr valign=top><td>13</td><td>NAM - No Address Multiplexing</td>
<td>Some implementations will require external multiplexing support. 
For instance, if there is an external master accessing the DRAM or 
if a linear addressing scheme is required the SADRAMC multiplexing 
may not be sufficient. In these cases, it would be advantageous
to prevent the SADRAMC from multiplexing the addresses on a DRAM access. 
If this bit is set to a 1, the SADRAMC will not multiplex the 
external address bus to provide column addresses.</td><td>0</td></tr>

<tr valign=top><td>12</td><td>COC - Command On Clock enable</td>
<td>
Implementations that utilize external multiplexing must have support for command
information to be multiplexed onto the SDRAM address bus. This bit allows the command
information to be driven out on what is normally the SDRAM clock enable (SCKE). In this
case, the SADRAMC will not support self refresh operation, but external support may be
generated. If the COC bit is set, the address command bit information will be generated
on the SCKE pin. External multiplexing will be responsible for putting the command
information on the proper address bit.</td><td>0</td></tr>

<tr valign=top><td>11</td><td>IS - Initiate Self-refresh command</td>
<td>
This bit tells the DRAM controller to send the SELF command to both banks to cause the
SDRAMs to enter into low-power self-refresh state where they will remain until the IS bit
is cleared. When the IS bit is cleared, the DRAM controller will send the SELFX command
to the SDRAMs to tell them to exit the self-refresh state. The refresh counter is suspended
while the SDRAMs are in self-refresh. This bit is only relevent if the CPU is to be placed
in low power mode. The BCM550 doesn't do this.</td><td>0</td></tr>

<tr valign=top><td>10,9</td><td>RTIM - Refresh TIMing</td><td>
These bits will determine the timing operation of Auto-Refresh in the SADRAMC.
Specifically, it will determine the number of clocks inserted between the REF command
and the next possible ACTV command. This same timing is used for both banks of the
SADRAMC. This corresponds to tRC in the SDRAM specifications. It is given as 90nsec.
1/45mhz = 22nsec a cycle. Options are 3 and 6cycles, 3 gives 66 nsec, which is too short. 
6 gives gives 133 nsec which is heaps.</td><td>01</td></tr>
<tr valign=top><td>8->0</td><td>Refresh Count - RC</td>
<td>
This field controls the frequency of refresh performed by the SADRAMC. 
One is added to the value stored in these register locations and 
multiplied by 16 bus clocks to determine the refresh period. The 
Refresh count is obtained from the SDRAM refresh cycle timing which states:<br> 
4096 refresh cycles in 64msecs.<br>
64/4096 = .015625 msec a refresh <br>
1/45mhz = .0000222 msec<br>
0.015625/0.0000222 = 703.125 bus clocks.<br>
To convert this to a RC field value, RC = (703.125/16)-1=42.945.<br> 
You round down as refresh have to be occure faster than minimum. A value of 42 is used.<br>
The actual refresh time will be (42 +1)*16/45mhz = 15.28 usec
</td><td>00101011</td></tr>
</table>
	
	<pre> <code>
	\ dram control register
	$100 #mba + CONSTANT _wreg_DCR
		$8000 CONSTANT _#dcr_syncronous_mode
		$0200 CONSTANT _#dcr_refresh_timing
		$002A CONSTANT _#dcr_refresh_count
	</code> </pre>

<a name="DACRx"></a>
<h4>Address and Control Register ( DACRx ) </h4>
<p>
DARRx contain base address compare value and the control bits for both
banks 0 and 1 of the DRAM controller. 
Address and timing are also controlled by bits in
the DACRx registers.
</p>
<table>
<caption>DACRx</caption>
<tr><th>bit</th><th>name</th><th>Comment</th><th>BCM550</th></tr>
<tr valign = top><td>31->18</td><td>BA - Base Address Register</td><td> 
These register bits are used in conjunction with the BAM bits 
in the DCMR to determine the address range in which the associated 
bank of DRAM will be located. Each bit is compared with the 
corresponding address of the bus cycle in progress. If each bit matches, 
or if bits that do not match are masked in the BAM, the address hits in the
associated bank’s DRAM block.</td>
<td>DACR0 0001 0000 0000 00<br>DACR1 0001 0001 0000 00</td></tr>

<tr valign=top><td>17,16</tr><td></td><td>Reserved</td><td>00</td></tr>

<tr valign=top><td>15</td><td>RE - Refresh Enable</td>
<td> 
This bit determines if the SADRAMC will generate a refresh cycle 
to the associated DRAM bank. This bit is reset to zero to ensure that
the refresh function is disabled at reset. In the end this bit will be set
</td> <td>1</td></tr>

<tr valign=top><td>14</tr><td></td><td>Reserved</td><td>00</td></tr>

<tr valign=top><td>13,12</td><td>CASL - Column Address Strobe Latency</td>
<td> 
These bits determine how long the data is delayed after the CAS signal (or the read
command) is asserted during a SDRAM access. This data delay corresponds to the tRCD 
( 30nsec = 2 cycles) specification in most SDRAMs. 
This also implies other timings with respect to the SDRAM.
These include active command to precharge command (tRAS ?? ), precharge command to
active command (tRP 30nsec=2 cycles ), last data input to precharge command (tRWL ??), 
and last data out to early precharge (tEP ?? ). 
	<table>
	<tr><th>CASL[1:0]</th><th>tRCD</th><th>tRAS</th><th>tRP</th><th>tRWL</th><th>tEP</th>
	<tr><td>00</td><td>1</td><td>2</td><td>1</td><td>1</td><td>1</td></tr>
	<tr><td><b>01</b></td><td>2</td><td>4</td><td>2</td><td>1</td><td>1</td></tr>
	<tr><td>10</td><td>3</td><td>6</td><td>3</td><td>2</td><td>1</td></tr>
	<tr><td>11</td><td>3</td><td>6</td><td>3</td><td>2</td><td>1</td></tr>
	</table>
Note the last column of the above table changed from early to late 
revisions of the user's manual.

</td>
<td>01</td></tr>

<tr valign=top><td>11</tr><td></td><td>Reserved</td><td>00</td></tr>

<tr valign=top><td>10,9,8</td><td><a name="CBM">CBM</a> - Command and Bank Mux</td>
<td>
Because different SDRAM configurations will cause the bank and column bits to
correspond to different addresses these resources have been made programmable.
These bits will determine the addresses these onto which these functions will be
multiplexed. Table below shows the encoding of these bits. 
This encoding along with the address multiplexing scheme handles common 
organizations of 16-Mbit SDRAMs, as well as some organizations of 4-Mbit, 
and allowing room for future 64-Mbit implementations. 
Note that the bank select bits include a base bit and all address bits above. 
This is to allow for future implementations of SDRAM that have more than one 
bank select bit. The selected value has address line 22 and up used for bank select.
<table>
<tr><th>CBM[2:0]</th><th>COMMAND BIT</th><th>BANK SELECT BITS</th></tr>
<tr><td>000</td><td>17</td><td>18 & UP</td></tr>
<tr><td>001</td><td>18</td><td>19 & UP</td></tr>
<tr><td>010</td><td>19</td><td>20 & UP</td></tr>
<tr><td>011</td><td>20</td><td>21 & UP</td></tr>
<tr><td><b>100</b></td><td>21</td><td>22 & UP</td></tr>
<tr><td>101</td><td>22</td><td>23 & UP</td></tr>
<tr><td>110</td><td>23</td><td>24 & UP</td></tr>
<tr><td>111</td><td>24</td><td>25 & UP</td></tr>
</table>
</td><td>100</td></tr>\

<tr valign=top><td>6</td><td>IMRS - Mode Register Set Command</td>
<td>
This bit will generate the Mode Register Set (MRS) command to the associated SDRAMs.
To use this feature, the base address and mask registers must be set. The associated
<a HREF="#CBM">CBM</a> bits should also be initialized. After the IMRS bit is set, the next access to the
address space of the SDRAM will cause the MRS command to that SDRAM to be
generated. The address of the access should be selected in order to place the correct
mode information on the address pins of the SDRAM. This bit is set to initiate a MRS
command. The DRAM controller will clear the bit when the command is finished. Table
11-28 summarizes the function of the IMRS Bit. Any accesses via the IMRS bit should be
restricted to be no wider than the port size programmed in the PS bits.
</td><td>-</td><tr>

<tr valign=top><td>5,4</td><td>PS - Port Size</td>
<td>
These two bits will determine the port size of the associated bank of SDRAM which will
allow for dynamic sizing of the associated accesses.
<table>
<tr><th>PS[1:0]</th><th>PORT SIZE</th><tr>
<tr><td><b>00</b></td><td>32-Bit Port</td></tr>
<tr><td>01</td><td>8-Bit Port</td></tr>
<tr><td>10</td><td>16-Bit Port</td></tr>
<tr><td>11</td><td>16-Bit Port</td></tr>
</table>
</td>
<td>00</td></tr>

<tr valign=top><td>3</td><td>IP - Initiate Precharge all command</td>
<td>
This bit will cause a Precharge All (PALL) command to be generated to the associated
SDRAM bank. This is useful in the power up sequence of SDRAMs. In order to use this
feature, the base address and mask registers must be set. The associated <a HREF="#CBM">CBM</a> bits
should also be initialized. After the IP bit is set, the next access to the address space of
the SDRAM will cause the PALL command to that SDRAM bank to be generated. It is
automatically cleared by the DRAM controller after the PALL command is finished. Any
accesses via the IP bit should be restricted to be no wider than the port size programmed
in the PS bits, otherwise two address cycles will be generated and only one is required.
</td>
<td>
-
</td><tr>

<tr valign=top><td>2</td><td>PM - Page Mode</td>
<td>
This bit determines how the associated SDRAM bank supports page mode operation.
<table>
<tr><th>PM</th><th>FUNCTION</th></tr>
<tr><td>0</td><td>Page Mode on Bursts Only</td></tr>
<tr><td><b>1</b></td><td>Continuous Page Mode</td></tr>
</table>
</td><td>1</td></tr>

<tr valign=top><td>1,0</tr><td></td><td>Reserved</td><td>00</td></tr>

</table>
	<pre> <code>
	\ address and control register bank 0
	$108 #mba + CONSTANT _lreg_DACR0
		$00008000 CONSTANT _#dacrx_RE    \ Refresh enable
		$00001000 CONSTANT _#dacrx_CASL  \ Column address strobe latency 01
		$00000400 CONSTANT _#dacrx_CBM   \ Command and bank mux address line 22 and up
		$00000040 CONSTANT _#dacrx_IMRS  \ Initiate mode register set
		$00000008 CONSTANT _#dacrx_IP    \ Initiate precharge all
		$00000004 CONSTANT _#dacrx_PM
		$00000000 CONSTANT _#dacrx_PS    \ Port size 32 bit
	\ mask register bank 0
.S .( _#dacrx_PS  )
	</code> </pre>
<a name="DMRx"></a>
<h4>Mask Register ( DMRx ) </h4>
<p>
DRAM Controller Mask Registers - DMR0 & DMR1 MBAR+$10C,114.
These registers contain bits to mask off the compare function for addresses as well as to
control response to certain Transfer Type/Transfer Modifier combinations.
</p>
<table>
<caption>DCR</caption>
<tr><th>Bit</th><th>Name</th><th>Comment</th><th>BCM550</th></tr>
<tr valign=top><td>31->18</td><td>BAM - Base Address Mask</td>
<td>
This register bits are provided to allow the user to mask or “don’t care” 
the associated bit in the Base Address (BA) register. 
If the bit is zero, the associated address is ignored to generate the DRAM hit. 
This lets you connect various size DRAMs to the SADRAMC. Each sdram bank is 16meg long
</td><td>00 0000 0011 1111</td><tr>

<tr valign=top><td>17,9</td><td></td><td>Reserved</td><td>00</td></tr>

<tr valign=top><td>8</td>
<td>WP - Write Protect</td>
<td>
This bit determines if the associated bank of DRAM is write protected. If the bit is set, write
accesses to the block of memory space occupied by the DRAM bank will be ignored by
the DRAM Controller.</td><td>0</td><tr>
<tr valign=top><td>7->1</td><td>C/I, AM, SC, SD, UC, UD - Address Modifier Masks</td>
<td>
These bits allow the associated type of access to be allowed to access DRAM. Table below 
shows the definition of the bits. If the bit is one, the associated access type is 
ignored. If the bit is zero, the associated access type is allowed to 
hit in the DRAM space. 
<table>
<tr><th>ADDRESS MODIFIER BIT</th><th>ASSOCIATED ACCESS TYPE</th></tr>
<tr><td>C/I</td><td>CPU Space / Interrupt Acknowledge</td></tr>
<tr><td>AM</td><td>Alternate Master</td></tr>
<tr><td>SC</td><td>Supervisor Code</td></tr>
<tr><td>SD</td><td>Supervisor Data</td></tr>
<tr><td>UC</td><td>User Code</td></tr>
<tr><td>UD</td><td>User Data</td></tr>
</table>
</td>
<td>100000</td></tr>

<tr valign=top><td>0</td><td>V - Valid</td>

<td>
This bit is set to show that the registers that control the associated 
bank of DRAM have been initialized, and that the DRAM Controller can begin 
to decode DRAM accesses. 
</td><td>1</td></tr>
</table>
	<pre> <code>
	$10C #mba + CONSTANT _lreg_DMR0
		$00FC0000 CONSTANT _#dmrx_address_mask
		$00000040 CONSTANT _#dmrx_addr_modifiers
		$00000001 CONSTANT _#dmrx_valid
	</code> </pre>
<p>
See bank 0 for full description.
</p>
	<pre> <code>
	\ address and control register bank1
	$110 #mba + CONSTANT _lreg_DACR1
	\ mask register bank 1
	$114 #mba + CONSTANT _lreg_DMR1 
	</code> </pre>
<h3>Timer 1</h3>
<p>
See section 12 of the user's manual
</p>
<a name="timer1"></a>
<p>
Even if cpu locks up the 10msec interrupt has to continue.
</p>
<h4>Timer 1 mode</h4>
<table>
<tr><th>Bit</th><th>Name</th><th>Comment</th><th>Value</th></tr>	
<tr valign=top><td>15->8</td><td>PS - Prescaler Value</td>
<td>
The prescaler is programmed to divide the clock input by values (system bus clock/(16 or 1)
or clock on TIN pin) from 1 to 256. The binary value 00000000 divides the clock by 1; the
value 11111111 divides the clock by 256.
</td><td>00001111 ( 0F)</td></tr>
<tr valign=top><td>7,6</td><td>CE -Capture Edge and Enable Interrupt</td>
<td>
11 = Capture on any edge and enable interrupt on capture event<br>
10 = Capture on falling edge only and enable interrupt on capture event<br>
01 = Capture on rising edge only and enable interrupt on capture event<br>
00 = Disable interrupt on capture event<br>
</td><td>00</td></tr>
<tr valign=top><td>5</td><td>OM - Output Mode</td>
<td>
1 = Toggle output<br>
0 = Active-low pulse for one system bus clock cycle (22ns at 45MHz)<br>
</td><td>0</td></tr>
<tr valign=top><td>4</td><td>ORI - Output Reference Interrupt Enable</td>
<td>
1 = Enable interrupt upon reaching the reference value<br>
0 = Disable interrupt for reference reached (does not affect interrupt on capture
function)
</td><td>1</td></tr>
<tr valign=top><td>3</td><td>FRR - Free Run/Restart</td>
<td>
1 = Restart: Timer count is reset immediately after reaching the reference value<br>
0 = Free run: Timer count continues to increment after reaching the reference value
</td><td>1</td></tr>
<tr valign=top><td>2,1</td><td>CLK - Input Clock Source for the Timer</td>
<td>
11 = TIN pin (falling edge)<br>
10 = System bus clock divided by 16. Note that this clock source is not synchronized
to the timer; thus successive time-outs may vary slightly in length<br>
01 = System bus clock divided by 1<br>
00 = Stop count<br>
</td><td>01</td></tr>
<tr valign=top><td>0</td><td>RST - Reset Timer</td>
<td>
This bit performs a software timer reset similar to that of an external reset, although while
this bit is zero, the other register values can still be written, if necessary. Effectively, a
transition of this bit from one to zero is what resets the register values. The counter/timer/
prescaler will not be clocked unless the timer is enabled.<br>
1 = Enable timer<br>
0 = Reset timer (software reset<br>
</td>
<td>1</td></tr>
</table>
	<pre> <code>
	\ timer1 mode register
	$140 #mba + CONSTANT _wreg_TMR1
		$0F 8 LSHIFT CONSTANT _#tmr1_PS  \ divide by 16
		$0000 CONSTANT _#tmr1_CE	     \ don't use capture mode
		$0020 CONSTANT _#tmr1_OM         \ pulse output  
		$0010 CONSTANT _#tmr1_ORI        \ interrupt on output
		$0008 CONSTANT _#tmr1_FRR        \ free running
		$0002 CONSTANT _#tmr1_CLK        \ system clock
		$0001 CONSTANT _#tmr1_RST        \ enable timer
		.S .( _#tmr1_RST )
	</code> </pre> 

<h4>timer1 reference register</h4>
<p>
1/45000000 * 1 * n * m = .01<br>
n*m = 450000 = 16 * 28125<br>
</p>
	<pre> <code>
	$144 #mba + CONSTANT _wreg_TRR1
		#28125 CONSTANT _#trr1_value
	</code> </pre>
<h4>timer1 capture register</h4>
	<pre> <code>
	$148 #mba + CONSTANT _wreg_TCR1
	</code> </pre>
<h4>timer1 counter register</h4>
	<pre> <code>
	$14C #mba + CONSTANT _wreg_TCN1
	</code> </pre>
<h4>timer1 event register</h4>
<p>Writing true to the appropiate bit resets the interrupt</p>
	<pre> <code>
	$151 #mba + CONSTANT _breg_TER1
		01 CONSTANT _#ter1_CAP
		02 CONSTANT _#ter1_REF
	</code> </pre>
<h3>Timere 2</h3>
<p>Watchdog timer, this timer is reset at the end  of #task_level_clock_medium. TIN 
toggles every 10msec, count therefor increments every 20msec.</p> 
<h4>timer2 mode register</h4>
	<pre> <code>
	.S .( before _wreg_TMR2)
	$180 #mba + CONSTANT _wreg_TMR2
		$00 $8 LSHIFT CONSTANT _#tmr2_PS  \ No prescale required
		$0000 CONSTANT _#tmr2_CE	        \ don't use capture mode
		$0000 CONSTANT _#tmr2_OM         \ pulse output  
		$0010 CONSTANT _#tmr2_ORI        \ interrupt on output
		$0008 CONSTANT _#tmr2_FRR        \ free running
		$0003 CONSTANT _#tmr2_CLK        \ system clock
		$0001 CONSTANT _#tmr2_RST        \ enable timer
	</code> </pre>
<h4>timer2 reference register</h4>
<p>Set inital watchdog value to 2sec
	<pre> <code>
	$184 #mba + CONSTANT _wreg_TRR2
		#2sec 2 / CONSTANT _#trr2_value
	</code> </pre>
<h4>timer2 capture register</h4>
	<pre> <code>
	$188 #mba + CONSTANT _wreg_TCR2
	</code> </pre>
<h4>timer2 counter register</h4>
	<pre> <code>
	$18C #mba + CONSTANT _wreg_TCN2
	</code> </pre>
<h4>timer2 event register</h4>
<p>Writing true to the appropiate bit resets he interrupt</p>
	<pre> <code>
	$191 #mba + CONSTANT _breg_TER2
		01 CONSTANT _#ter2_CAP
		02 CONSTANT _#ter2_REF

	</code> </pre>
<h4>UART</h4>
<p>See section 14 of the users manual<p>
	<pre> <code>
	\ register offsets, common code is used to control both uarts
	| 00 CONSTANT _#m68_mode
	| 04 CONSTANT _#m68_clock_select
	| 04 CONSTANT _#m68_status
	| 08 CONSTANT _#m68_control
    | 0C CONSTANT _#m68_data
	| 10 CONSTANT _#m68_aux_control
	| 14 CONSTANT _#m68_int_enable
	| 14 CONSTANT _#m68_int_state
	| 18 CONSTANT _#m68_prescaler_MSB
	| 1C CONSTANT _#m68_prescaler_LSB
	| 30 CONSTANT _#m68_int_vector
	| 34 CONSTANT _#m68_input_port
	| 38 CONSTANT _#m68_output_set
	| 3C CONSTANT _#m68_output_reset
.S .( _#m68_output_reset)

	\ uart1 mode register 1
	\ Note the mode registers have the same offset.
	\ A write command issued to _breg_UCR1 will reset the
	\ register pointer. An access to the mode registers 
	\ will increment the pointer.  
	$1C0 #mba + CONSTANT _#m68a_base
	_#m68a_base _#m68_mode +          CONSTANT _breg_UMR11
	_#m68a_base _#m68_mode +          CONSTANT _breg_UMR21
	\ uart1 status register, read
	_#m68a_base _#m68_status +        CONSTANT _breg_USR1      
	\ uart1 clock select register, write
	_#m68a_base _#m68_clock_select +  CONSTANT _breg_UCSR1      
	\ uart1 command register
	_#m68a_base _#m68_control +       CONSTANT _breg_UCR1
	\ uart1 receive buffer, read
	_#m68a_base _#m68_data +          CONSTANT _breg_URB1
	\ uart1 transmit buffer, write
	_#m68a_base _#m68_data +          CONSTANT _breg_UTB1
	\ uart1 input port change register, read
	_#m68a_base _#m68_aux_control +   CONSTANT _breg_UIPCR1
	\ uart1 auxilary control register, write
	_#m68a_base _#m68_aux_control +   CONSTANT _breg_UACR1
	\ uart1 interrupt status register, read
	_#m68a_base _#m68_int_state +     CONSTANT _breg_UISR1
	\ uart1 interrupt mask register
	_#m68a_base _#m68_int_enable +    CONSTANT _breg_UIMR1
	\ uart1 baud rate prescaler ( MSB) 
	_#m68a_base _#m68_prescaler_MSB + CONSTANT UBG11
	\ uart1 baud rate prescaler ( LSB)
	_#m68a_base _#m68_prescaler_LSB + CONSTANT UBG21
	\ uart1 interrupt vector register
	_#m68a_base _#m68_int_vector +    CONSTANT UIVR1
	\ uart1 input port register
	_#m68a_base _#m68_input_port +    CONSTANT UIP1
	\ uart1 output port bit set register
	_#m68a_base _#m68_output_set +    CONSTANT UOP11
	\ uart1 output port bit reset register
	_#m68a_base _#m68_output_reset +  CONSTANT UOP01 


	\ uart2 mode register 1
	\ Note the mode registers have the same offset.
	\ A write command issued to _breg_UCR1 will reset the
	\ register pointer. An access to the mode registers 
	\ will increment the pointer.  
	$200 #mba + CONSTANT _#m68b_base
	_#m68b_base _#m68_mode +          CONSTANT _breg_UMR12
	_#m68b_base _#m68_mode +          CONSTANT _breg_UMR22
	\ uart1 status register, read
	_#m68b_base _#m68_status +        CONSTANT _breg_USR2     
	\ uart1 clock select register, write
	_#m68b_base _#m68_clock_select +  CONSTANT _breg_UCSR2      
	\ uart1 command register
	_#m68b_base _#m68_control +       CONSTANT _breg_UCR2
	\ uart1 receive buffer, read
	_#m68b_base _#m68_data +          CONSTANT _breg_URB2
	\ uart1 transmit buffer, write
	_#m68b_base _#m68_data +          CONSTANT _breg_UTB2
	\ uart1 input port change register, read
	_#m68b_base _#m68_aux_control +   CONSTANT _breg_UIPCR2
	\ uart1 auxilary control register, write
	_#m68b_base _#m68_aux_control +   CONSTANT _breg_UACR2
	\ uart1 interrupt status register, read
	_#m68b_base _#m68_int_state +     CONSTANT _breg_UISR2
	\ uart1 interrupt mask register
	_#m68b_base _#m68_int_enable +    CONSTANT _breg_UIMR2
	\ uart1 baud rate prescaler ( MSB) 
	_#m68b_base _#m68_prescaler_MSB + CONSTANT UBG12
	\ uart1 baud rate prescaler ( LSB)
	_#m68b_base _#m68_prescaler_LSB + CONSTANT UBG22
	\ uart1 interrupt vector register
	_#m68b_base _#m68_int_vector +    CONSTANT UIVR2
	\ uart1 input port register
	_#m68b_base _#m68_input_port +    CONSTANT UIP2
	\ uart1 output port bit set register
	_#m68b_base _#m68_output_set +    CONSTANT UOP12
	\ uart1 output port bit reset register
	_#m68b_base _#m68_output_reset +  CONSTANT UOP02 
	</code> </pre>
<h4>Parallet port</h4>
<p>
See section 10 of the users manual.
See also _wreg_PAR.
</p>
	<pre> <code>
	\ parallel port data direction register
	$244 #mba + CONSTANT _wreg_PADDR
	\ parallet port data register
	$248 #mba + CONSTANT _wreg_PADAT
	</code> </pre>
<h4>MBUS</h4>
<p>
See section 15 of the users manual.
</p>
	<pre> <code>
	\ mbus address register
	$280 #mba + CONSTANT _breg_MADR
	\ mbus frequency register
	$284 #mba + CONSTANT _breg_MFDR
	\ mbus control register
	$288 #mba + CONSTANT _breg_MBCR
	\ mbus status register
	$28C #mba + CONSTANT _breg_MBSR
	\ mbus data register
	$290 #mba + CONSTANT _breg_MBDR
	</code> </pre>

<h4>DMA controller</h4>
<p>
See section 13 of the users manual
</p>
	<pre> <code>
	\ dma0 source address register 1
	$300 #mba + CONSTANT _lreg_SAR0
	\ dma0 destination address register 1
	$304 #mba + CONSTANT _lreg_DAR0
	\ dma0 control register 
	$308 #mba + CONSTANT _wreg_DCR0
		8000 CONSTANT _#dcrx_INT    \ enable interrupt on termination
		4000 CONSTANT _#dcrx_EEXT   \ external request
		2000 CONSTANT _#dcrx_CS     \ cycle steal
		1000 CONSTANT _#dcrx_AA     \ auto align
		0100 CONSTANT _#dcrx_SAA    \ single address mode
		0080 CONSTANT _#dcrx_S_RW   \ one = read
		0040 CONSTANT _#dcrx_SINC   \ source increment
		0008 CONSTANT _#dcrx_DINC   \ destination inc
		0001 CONSTANT _#dcrx_START  \ start
	\ dma0 count register
	$30C #mba + CONSTANT _wreg_BCR0
	\ dma0 status register
	$310 #mba + CONSTANT _breg_DSR0
	\ dma0 interrupt vector register
	$314 #mba + CONSTANT _breg_DIVR0

	\ dma1 source address register 1
	$340 #mba + CONSTANT _lreg_SAR1
	\ dma1 destination address register 1
	$344 #mba + CONSTANT _lreg_DAR1
	\ dma1 control register 
	$348 #mba + CONSTANT _wreg_DCR1
		0006 CONSTANT _#dcr1_DSZE
		0030 CONSTANT _#dcr1_SSZE
	\ dma1 count register
	$34C #mba + CONSTANT _wreg_BCR1
	\ dma1 status register
	$350 #mba + CONSTANT _breg_DSR1
	\ dma1 interrupt vector register
	$354 #mba + CONSTANT _breg_DIVR1

	\ dma2 source address register 1
	$380 #mba + CONSTANT _lreg_SAR2
	\ dma2 destination address register 1
	$384 #mba + CONSTANT _lreg_DAR2
	\ dma2 control register 
	$388 #mba + CONSTANT _wreg_DCR2
	\ dma2 count register
	$38C #mba + CONSTANT _wreg_BCR2
	\ dma2 status register
	$390 #mba + CONSTANT _breg_DSR2
	\ dma2 interrupt vector register
	$394 #mba + CONSTANT _breg_DIVR2

	\ dma3 source address register 1
	$3C0 #mba + CONSTANT _lreg_SAR3
	\ dma3 destination address register 1
	$3C4 #mba + CONSTANT _lreg_DAR3
	\ dma3 control register 
	$3C8 #mba + CONSTANT _wreg_DCR3
	\ dma3 count register
	$3CC #mba + CONSTANT _wreg_BCR3
	\ dma3 status register
	$3D0 #mba + CONSTANT _breg_DSR3
	\ dma3 interrupt vector register
	$3D4 #mba + CONSTANT _breg_DIVR3
	</code> </pre>
<h3>function_data</h3>
	<pre> <code>
	\ latch value. This is used to ID the software 
	\ version.
	_#function_data_base #00 + CONSTANT _breg_ID
	\ Interrupt reset must be done with a write, using a read can
	\ cause problems because a single read can result in multiple read
	\ cycles.
	\ Reset digital interrupt 1 
	_#function_data_base #02 + CONSTANT _breg_int_reset_digital0 
	\ Reset digital interrupt 2
	_#function_data_base #03 + CONSTANT _breg_int_reset_digital1 
	\ Reset interrupt for RTI Ac_low
	_#function_data_base #04 + CONSTANT _breg_int_reset_aclow
	\ Reset interrupt for RTI sys_fail 
	_#function_data_base #05 + CONSTANT _breg_int_reset_sys_fail
	\ Reset interrupt remote I/O 
	_#function_data_base #06 + CONSTANT _breg_int_reset_remote_i/o
	\ Reset bus error interupt
	_#function_data_base #07 + CONSTANT _breg_int_reset_bus_error
	\ end of service interrupt NICE controller ( DMA interrupt )
	_#function_data_base #10 + CONSTANT _breg_int_reset_ethernet
	\ system setup 0
 	_#function_data_base #27 + CONSTANT _breg_SS0 \ system_setup 0
		\ have to set to one.
		$0001 CONSTANT _#SS0_enable_logic  \ enables flip flops in fpga
		\ cause card to reset, this how I should reset card, don't use reset instruction
		$0002 CONSTANT _#SS0_self_reset
		\ if timer 2 times out and this bit is set card will do reset.
		$0004 CONSTANT _#SS0_enable_watchdog
		\ Set to remove RTI reset line.
		$0008 CONSTANT _#SS0_enable_rti
		\ enable bus error
		$0010 CONSTANT _#SS0_enable_bus_error
		$0040 CONSTANT _#SS0_port0>RS485
		$0080 CONSTANT _#SS0_port1>full_duplex
	_#function_data_base #28 + CONSTANT _breg_SS1 \ system setup 1
	\ Three leds
		$0001 CONSTANT _#SS1_dram_fault
		$0002 CONSTANT _#SS1_no_buffer_memory
		$0004 CONSTANT _#SS1_processor_fault
	\ digital interrupts
	\ bits 4 and 5 control digital interrupt 0
	\ 00 = no interrupt
	\ 01 = interrupt on falling edge.
	\ 10 = interrupt rising edge
	\ 11 = interrupt on both
	\ system status
		$0010 CONSTANT _#SS1_dig1_falling
		$0020 CONSTANT _#SS1_dig1_rising

		$0040 CONSTANT _#SS1_dig2_falling
		$0080 CONSTANT _#SS1_dig2_rising

	_#function_data_base #29 + CONSTANT _breg_SST0
		$0001 CONSTANT _#SST0_in_slotx
		
		\ 01 = base
		\ 11 = remote
		\ 10 = local

		$0008 CONSTANT _#SST0_digital_input1
		$0010 CONSTANT _#SST0_digtial_input2

	\ Use only the kernel
	$2 CONSTANT _#cold_restart
	\ Use startup script
    $6 CONSTANT _#warm_restart
	\ Use saved application
	$4 CONSTANT _#normal_restart
	
	$06 CONSTANT _#restart_method_bits

	\ Interrupt status register
	\ All interrupts are autovectored from base $90
	_#function_data_base #30 + CONSTANT _#IS2
		$0001 CONSTANT _#IS_digital_input1
		$0002 CONSTANT _#IS_digital_input2
		$0004 CONSTANT _#IS_ac_low
		$0008 CONSTANT _#IS_sysfail
		$0010 CONSTANT _#IS_remote_i/o
	\ fpga version
	_#function_data_base #31 + CONSTANT _breg_FPGA
		$0A1 CONSTANT _#FPGA_version
	\ Set RTI1000 interrupt ( slave mode only)
	_#function_data_base #32 + CONSTANT _#set_rti1000_interrupt
	\ Reset interrupt from master ( slave mode only)
	_#function_data_base #33 + CONSTANT _#reset_rti1000_interrupt
	</code> </pre> 
<h3>Interrupt vectors</h3>
	<pre> <code>
	$1F CONSTANT  #buss_error_vector
	$60 CONSTANT _#m68a_vector
	$61 CONSTANT _#m68b_vector 
	$62 CONSTANT _#dma0_vector
	$63 CONSTANT _#dma1_vector
	$64 CONSTANT _#dma2_vector
	$65 CONSTANT _#dma3_vector

	</code> </pre>
<p>
Describe the cache, needed for cache flushed.
</p>
	<pre> <code>
	2000 CONSTANT _#cache_size
	0010 CONSTANT _#cache_line_size
	0004 CONSTANT _#cache_sets
	.S .( end MCF5307_constants.html)
	</code> </pre>
	<pre> <code>	 
	\ The kernel checksum can't go at the start because that is where the restart 
	\ vector is stored. So it is placed at the end,
	_prom_kernel_end 4 -                     EQU _prom_kernel_checksum
	_prom_kernel_end 8 -                     EQU _prom_kernel_count
 
	_prom_kernel_end                         EQU _prom_dictionary_image_start
	_prom_dictionary_image_start
	_#dictionary_image_size +                EQU _prom_dictionary_image_end

	_prom_dictionary_image_start             EQU _prom_dictionary_checksum
	_prom_dictionary_image_start 4 +         EQU _prom_dictionary_count

	_prom_kernel_start CONSTANT _interrupt_vectors  ( Start of interrupt vectors )

	\ Section 3.2.2 of user's manual
	_interrupt_vectors 0FFFFF AND 0 ??=


	                       
	_prom_kernel_end                  EQU _#dictionary_start
	800000 _#dictionary_start +       EQU _#dictionary_end  ( End of user dictionary)
	_#dictionary_end                  EQU RMEM4  ( Start of RAM area )
	_#sdram0_base _#sdram0_size + 1 - EQU RMEM5  ( End of ram area)

	100000   EQU _#dictionary_flash_base
	60000    EQU _#dictionary_flash_size


	\ Buffers must be in non cached area as you must be able to DMA
	_#sdram1_base $200000 + CONSTANT _#heap_start _#sdram1_size
	_#sdram1_base + CONSTANT _#heap_end
	</code> </pre>
</body>
</html>
