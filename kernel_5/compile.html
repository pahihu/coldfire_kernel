<html>
<head>
<title>COLDFORTH KERNEL</title>
<META NAME="Author" CONTENT="Charles Esson">
<META NAME="keywords" CONTENT="forth"> 
<META NAME="description" CONTENT=" COLDFORTH uses this file to generate COLDFORTH">
<LINK REL=stylesheet HREF="forth.css" TYPE="text/css">
</head>

<body>

<h4>Words to set bits in the head</h4>
<a HREF="./license.html">license</a>
<a name="IMMEDIATE"></a> 
<h5> ANS  6.1.1710 IMMEDIATE</h5> 
<p>( -- )</p>
<p>
Make the most recent definition an immediate word. 
An ambiguous condition exists if the 
most recent definition does not have a name. 
</p>
<samp>
Typical use: : X ... ; IMMEDIATE 
</samp>
<p>
IMMEDIATE words carry a lot of baggage, refer to the ANS standard for clarification.
</p>
<p>
An immediate word will be executed when in the compiling state.
</p>
	<pre> <code>

	: IMMEDIATE	( --)   
		last			\ addr(-- contain last list added to 
		@				\ addr1(-- last list added to 
		@               \ addr2(-- address of last word
		lfa>nfa
		DUP C@          \ addr3 count (-- 
		_#immediate_bit OR 
		SWAP C! 
	;
	</code> </pre>

<p>
Sets a bit in the words name so it can't be found by FIND, allows you to redefine words.
</p>

	<pre> <code>
    : smudge  ( --)   
		last @ ?DUP IF
			                 \ thread(-- 
			@                \ lfa(-- 
			lfa>nfa          \ nfa(--
			DUP name_count   \ nfa addr count(-- 
			NIP              \ nfa count+flags(-- 
			_#smudge_bit  XOR  
			SWAP             \ count+flags nfa(--
			C! 
		THEN
	;
	</code> </pre>    
<p>
Set the inline bit in the words name field.
</p>

	<pre> <code> 
	: inline	( --)   
		last			\ addr(-- contain last list added to 
		@				\ addr1(-- last list added to 
		@               \ addr2(-- address of last word
		lfa>nfa
		DUP C@          \ addr3 count (-- 
		_#pure_bit OR 
		SWAP C! 
	;
	
	\ #### temp zap
	: pure_code inline ;
	</code> </pre>

<p>
Given xt work out how long the code fragment is.
</p>

	<pre> <code>
	: code_copy_length ( xt -- length )
		xt>cfa
		zero
		BEGIN
			2DUP + W@ 
			4E75  \ ##code RTS
			= IF
				NIP
				EXIT
			THEN
			2+
		AGAIN
	;
	</code> </pre>

<p>
Test to see if xt points to a pure code word. This will only
work if a word has a head. You can't find a word to compile it
if it doesn't have a head.
</p>
	<pre> <code>
	: ?inline ( xt --flag)
		xt>cfa
		cfa>nfa
		char@
		_#pure_bit AND 0<>
	; 
	</code> </pre>
<p>
If it is pure code copy the code fragment to the dictionary. If not do
a subroutine call.
</p>
	<pre> <code>
	| : _:compile, ( xt --) 
		DUP ?inline IF
			DUP xt>cfa \ xt cfa (--
			SWAP code_copy_length \ cfa num (--
			HERE SWAP             \ from to num (--
			DUP ALLOT               \ from to num (--
			MOVE                  \ (--            
		ELSE
			4EB9 W, xt>cfa , 
		THEN 
	;
	</code> </pre>
<a name="COMPILE,"></a>
<h5>6.2.0945 COMPILE,</h5> 
<p>compile-comma CORE EXT</p> 
<p>
Interpretation: Interpretation semantics for this word are undefined.
</p>
<p>
Execution: ( xt -- )
</p>
<p>
Append the execution semantics of the definition represented by xt to 
the execution semantics of the current definition.
</p> 
<p>
COMPILE, is the compilation equivalent of EXECUTE. In many cases, 
it is possible to compile a word by using POSTPONE
without resorting to the use of COMPILE,. However, the use of POSTPONE 
requires that the name of the word must be known
at compile time, whereas COMPILE, allows the word to be located at 
any time. It is sometime possible to use EVALUATE to
compile a word whose name is not known until run time. 
This has two possible problems: 
</p>
<p>
EVALUATE is slower than COMPILE, because a dictionary search is required. 
The current search order affects the outcome of EVALUATE. 
</p>
<p>
In traditional threaded-code implementations, compilation is performed by , 
(comma). This usage is not portable; it doesn't work
for subroutine-threaded, native code, or relocatable implementations. 
Use of COMPILE, is portable.
</p>
<p>
In most systems it is possible to implement COMPILE, so it will generate 
code that is optimized to the same extent as code that is
generated by the normal compilation process. However, in some 
implementations there are two different tokens corresponding to
a particular definition name: the normal execution token that 
is used while interpreting or with EXECUTE, and another
compilation token that is used while compiling. It is not always 
possible to obtain the compilation token from the execution token.
In these implementations, COMPILE, might not generate code that 
is as efficient as normally compiled code. 
</p>
<p>
Can't use _:copile in all cases as it requires a head.
This version always compiles a subroutine call.
</p>
	<pre> <code>
	: COMPILE, ( xt --) 
			4EB9 W, xt>cfa , 
	;


	\ Used in USE. This version patches the subroutine address found at the
	\ start of create.
	: _compile! ( addr cfa --) 2+ ! ;


	\ This version uses COMPILE, as the xt being compiled may be from a word that doesn't
	\ have a head.
    : _do_compile
		R@ @ COMPILE,
		R> CELL+ >R
	;

	
	: COMPILE 
		['] _do_compile COMPILE, ' , 
	;  IMMEDIATE

	forth : COMPILE ( --)
		HOST COMPILE _do_compile
		' t,
		forth
	; 
	TARGET
	HOST
	</code> </pre>
	<a name="RECURSE"></a>
<h5>ANS 6.1.2120 RECURSE</h5>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( -- )</p>
<p>Append the execution semantics of the current definition to the current definition. 
An ambiguous condition exists if RECURSE appears in a definition after DOES>. 
</p>
<pre> <samp>
Typical use: : X ... RECURSE ... ; 
</samp> </pre>
<p>
This is Forth's recursion operator; in some implementations it is called MYSELF. 
The usual example is the coding of the factorial function. 
</p>
<pre> <samp>
: FACTORIAL ( +n1 -- +n2)
    DUP 2 < IF  DROP 1 EXIT  THEN
    DUP 1-  RECURSE *
;
</samp> </pre>
<p> 
n2 = n1(n1-1)(n1-2)...(2)(1), the product of n1 with all positive integers less 
than itself (as a special case, zero factorial equals one). While beloved by computer
scientists, recursion makes unusually heavy use of both stacks and should therefore 
be used with caution.
</p>

	<pre> <code> 
	: RECURSE   ( --) 
		last @ @  lfa>xt  COMPILE, 
	;  IMMEDIATE  
    </code> </pre>
<a name="LITERAL"></a>
<h5>6.1.1780 LITERAL</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( x -- )</p>
<p>Append the run-time semantics given below to the current definition.</p> 
<p>Run-time: ( -- x )</p>
<p>Place x on the stack.</p> 
	<pre> <code>
    : LITERAL \ compile time ( n--)
	          \ runtime ( --n)
		2D3C W, \ ##code # S -) MOV
		,
    ;   IMMEDIATE 
    </code> </pre>
	
<a name=2LITERAL><h5>8.6.1.0390 2LITERAL</h5></a>
<p> two-literal DOUBLE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( x1 x2 -- )</p>
<p>Append the run-time semantics below to the current definition.</p> 
<p>Run-time: ( -- x1 x2 )</p>
<p>Place cell pair x1 x2 on the stack.</p>

	<pre> <code>
	: 2LITERAL \ compile time ( x1 x2 --)
	           \ runtime ( -- x1 x2 )
		2D3C W, \ ##code # S -) MOV
		SWAP ,
		2D3C W, \ ##code # S -) MOV
		,
	; IMMEDIATE 
	</code> </pre>
<a name="[']"></>
<h5>6.1.2510 [']</h5> 
<p>bracket-tick CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( " name" -- )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space. 
Find name. Append the run-time semantics given below to the current 
definition. 
</p>
<p>
An ambiguous condition exists if name is not found. 
</p>
<p>Run-time: ( -- xt )</p>
<p>
Place name's execution token xt on the stack. The execution token 
returned by the compiled phrase ['] X is the same value returned 
by ' X outside of compilation state.
</p> 
	<pre> <code>
	: ['] ( -- \ --addr)
		'  [COMPILE] LITERAL 
	;   IMMEDIATE
    </code> </pre>

	<pre> <code>
	: use ( addr  cfa  --) 
		last @ @  lfa>cfa  _compile! 
	;


	| : ;code  ( --)
		R> ( addr ) use
	;

        </code></pre>
        \ This version is used if ;CODE is used in the cross compiler code.
	\ As the aim is to remove all assember it is no longer used.
	forth : ;CODE
		HOST
		forth _%local_use @ IF
			forth _%local_input_bytes @ IF
				forth _%local_input_bytes @ 4 / 7000 OR
				     tw,  \ ##code # D0 MOV
				204D tw,                                \ ##cope LP A0 MOV
				                                        \ ##code BEGIN
				2D20 tw,                                \ ##code A0 -) S -) MOV
				5380 tw,                                \  ##code 1 # D0 SUB
				66FA tw,								\ ##code EQ UNTIL
			THEN
			    4E5D tw,                                \ ##code LP UNLK
			HOST target_previous
			     _end_xlocal_dictionary
		forth THEN
		_%t_save_op @ IF
			245F tw,  \ ##code R )+ OP MOV
			zero _%t_save_op !
		THEN
		HOST
	COMPILE ;code
               \ childs runtime action
               \ return address is data field address of child
		smudge
		forth
                285F W,  \ ##code R )+ W MOV
		FALSE tstate !
		[COMPILE] assembler
		HOST
   ;  TARGET
        <pre><code>
        </code> </pre>
<p>
This version is used IN target words that will create child words when the
target is running. See file XCOM2 for the definition of DOES> used in HOST
words that manipulate the target
It has to be defined after the target version of ;code is defined
</p>
	<pre> <code>
		forth : DOES>
			forth _%local_use @ IF
				_%local_input_bytes  @ IF
					_%local_input_bytes forth @ 4 / 7000 OR tw,  \ ##code # D0 MOV
					204D tw,                                      \ ##cope LP A0 MOV
					                                              \ ##code BEGIN
					2D20 tw,                                      \ ##code A0 -) S -) MOV
					5380 tw,                                      \ ##code 1 # D0 SUB
					66FA tw,                                      \ ##code EQ UNTIL
				THEN
				4E5D tw,                                          \ ##code LP UNLK
				target_previous
				_end_xlocal_dictionary
			THEN
			_%t_save_op  @ IF
				245F tw,  \ ##code R )+ OP MOV
				zero  _%t_save_op  !
			THEN
	    	HOST
			COMPILE ;code
			\ Host version of ['] this finds a word in the target
			\ and compiles the literal in the host.
			\ The assembler code is the host version, these words add code
			\ to the target.
			['] _do_does> t_xt>cfa assembler AB L. JSR
			( There is a host and forth version of ; we need the forth)
			( version, this ends a host word.)
			forth
    ; TARGET
	HOST
    </code> </pre>
<a name="CONSTANT"></a>
<h5>ANS 6.1.0950 CONSTANT</h5>
<p>\CORE</p>

<p>( x "name" -- )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space.
Create a definition for name with the execution semantics defined below.
</p>
<p>
name is referred to as a constant.
</p>
        <p>name Execution: ( -- x )</p>
<p>
Place x on the stack.
</p>

	<pre> <code>
	: CONSTANT
		CREATE
		_recover_cfa
		2D3C W,   \ ##code # S -) MOV
		,
		4E75 W,   \ ##code RTS
		inline  \ Tell system child word is pure code
	;
	</code> </pre>

<a name="2CONSTANT"><h5>ANS 8.6.1.0360 2CONSTANT</h5></a>
<p>two-constant DOUBLE</p>

<p>( x1 x2 "&lt;spaces&gt;name" -- )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space.
Create a definition for name with the execution semantics defined below.
</p>
<p>
name is referred to as a two-constant.
</p>
<p>name Execution: ( -- x1 x2 )</p>
<p>
Place cell pair x1 x2 on the stack.
</p>

	<pre> <code>
	: 2CONSTANT
		CREATE
		_recover_cfa
		2D3C W,   \ ##code # S -) MOV
		SWAP ,
		2D3C W,   \ ##code # S -) MOV
		,
		4E75 W,   \ ##code RTS
		inline  \ Tell system child word is pure code
	;
    </code> </pre>


<pre> <code>

	: user_create  ( --)
		CREATE
		_recover_cfa
		41EB W,   \ ##code  3) A0 LEA
		'user @ W,
		2D08 W,   \ ##code A0 S -) MOV
		4E75 W,       \ ##code RTS
		inline      \ Tell system child word is pure code
	;


	: user_variable   \ parent ( --)
              \ child  ( --addr)
                        user_create
			'user @ DUP CELL+   \ old new(--
			DUP _'user_top @ < not ABORT" Ran out of user space"  \ > old new(--
            'user !   \ old(--
	;


	: user_allot ( u --)
		'user @ +   \ old new(--
		DUP _'user_top @ < not ABORT" Ran out of user space"  \ > old new(--
		'user !   \ old(--
	;
	</code> </pre>
<a name="ubuffer"><h5>ubuffer</h5></a>

	<pre> <code>
	\ a buffer that is returned on an abort
	: ubuffer ( n--)
		CREATE
		'user             \ n addr (--
		@              \ n offset (--
		,              \ n (--
		cell 'user +!
		,              \ (--
	DOES>
		user_buffer_runtime
	;

	\ a buffer that remains once created
   	: ufree_buffer ( n--)
		CREATE
		'user             \ n addr (--
		@              \ n offset (--
		,              \ n (--
		cell 'user +!
		,              \ (--
		HERE
		%free_ubuffers @ , %free_ubuffers !
	DOES>
		user_free_buffer_runtime
	;

	</code> </pre>
<a name="colon"></a>
<h5>6.1.0450 :</h5>
<p>colon CORE</p>
<p>( C: "name" -- colon-sys )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space.
Create a definition for name, called a colon definition. Enter
compilation state and start the current definition, producing
colon-sys. Append the initiation semantics given below to the current
definition.
</p>
<p>
The execution semantics of name will be determined by the words compiled
into the body of the definition. The current definition
shall not be findable in the dictionary until it is ended
(or until the execution of DOES> in some systems).
</p>
<p>Initiation: ( i*x -- i*x )  ( R:  -- nest-sys )</p>
<p>
Save implementation-dependent information nest-sys about the calling definition.
The stack effects i*x represent arguments to name.
</p>
<p>
name Execution: ( i*x -- j*x )
</p>
<p>
Execute the definition name. The stack effects i*x and j*x represent
arguments to and results from name, respectively.
</p>
<p>
Typical use: : name ... ;
</p>
<p>
Note that colon does not itself invoke the compiler. Colon sets compilation
state so that later words in the parse area are compiled.
</p>
	<pre> <code>
    : : ( --)
    	CREATE
			_recover_cfa
			smudge
			@s csp !
			TRUE STATE !
			FALSE _%local_use !
			_%save_op @ IF
				2F0A W,  \ ##code OP R -) MOV
				245E W,  \ ##code S )+ OP MOV
			THEN

	;
	</code> </pre>
<a name=":NONAME"></a>
<h5>ANS 6.2.0455 :NONAME</h5>
<p>colon-no-name CORE EXT </p>
<p>
( C:  -- colon-sys )  ( S:  -- xt )
</p>
<p>
Create an execution token xt, enter compilation state and start the current definition,
producing colon-sys. Append the initiation semantics given below to the current definition.
</p>
<p>
The execution semantics of xt will be determined by the words compiled into the
body of the definition. This definition can be executed later by using xt EXECUTE.
</p>
<p>
If the control-flow stack is implemented using the data stack, colon-sys shall be the
topmost item on the data stack.
</p>
<p>
Initiation: ( i*x -- i*x ) ( R:  -- nest-sys )
</p>
<p>
Save implementation-dependent information nest-sys about the calling definition.
The stack effects i*x represent arguments to xt.
</p>
<p>
xt Execution: ( i*x -- j*x )
</p>
<p>
Execute the definition specified by xt. The stack effects i*x and j*x represent arguments to and results from xt, respectively.
</p>
<p>
:NONAME allows a user to create an execution token with the semantics of a
colon definition without an associated name. Previously, only : (colon) could
create an execution token with these semantics. Thus, Forth code could only
be compiled using the syntax of :, that is:
</p>
<pre> <samp>
        : NAME  ...  ;
</samp> </pre>
<p>
:NONAME removes this constraint and places the Forth compiler in the hands of the
programmer.
</p>
<p>
:NONAME can be used to create application-specific programming languages.
One technique is to mix Forth code fragments with application-specific
constructs. The application-specific constructs use :NONAME to compile
the Forth code and store the corresponding execution tokens in data structures.
</p>
<p>
The functionality of :NONAME can be built on any Forth system. For years, expert
Forth programmers have exploited intimate knowledge of their systems
to generate unnamed code fragments. Now, this function has been named and
can be used in a portable program.
</p>
<p>
For example, :NONAME can be used to build a table of code fragments where
indexing into the table allows executing a particular fragment. The
declaration syntax of the table is:
</p>
<pre> <samp>
:NONAME .. code for command 0 .. ;  0 CMD !

:NONAME .. code for command 1 .. ;  1 CMD !
   ...

:NONAME .. code for command 99 .. ; 99 CMD !

   ... 5 CMD @ EXECUTE ...
</samp> </pre>
<p>
The definitions of the table building words are:
</p>
<pre> <samp>
CREATE CMD-TABLE  \ table for command execution tokens
100 CELLS ALLOT

: CMD ( n -- a-addr ) \ nth element address in table
    CELLS CMD-TABLE + ;
</samp> </pre>
<p>
As a further example, a defining word can be created to allow performance monitoring.
In the example below, the number of times a word is executed is
counted. : must first be renamed to allow the definition of the new ;.
</p>
<pre> <samp>
: DOCOLON ( -- )     \ Modify CREATEd word to execute like a colon def
     DOES> ( i*x a-addr -- j*x )
     1 OVER +!         \ count executions
     CELL+ @ EXECUTE   \ execute :NONAME definition
;

: OLD: : ;           \ just an alias

OLD: : ( "name" -- a-addr xt colon-sys )
                     \ begins an execution-counting colon definition
     CREATE  HERE 0 ,  \ storage for execution counter
     0 ,               \ storage for execution token
     DOCOLON           \ set run time for CREATEd word
    :NONAME           \ begin unnamed colon definition
;
</samp> </pre>
<p>
( Note the placement of <i>DOES></i>: <i>DOES></i> must modify the <i>CREATE</i>d
word and not the <i>:NONAME</i> definition, so <i>DOES></i> must execute before <i>:NONAME</i>.)
</p>
<pre> <samp>
OLD: ; ( a-addr xt colon-sys -- )
                      \ ends an execution-counting colon definition )
    POSTPONE ;        \ complete compilation of colon def
    SWAP CELL+ !      \ save execution token
;  IMMEDIATE
</samp> </pre>
<p>
The new : and ; are used just like the standard ones to define words:
</p>
<pre> <samp>
        ... : xxx  ... ;  ...  xxx  ...
</samp> </pre>
<p>
Now however, these words may be ticked to retrieve the count (and execution token):
</p>
<pre> <samp>
        ... ' xxx >BODY ? ...
</samp> </pre>

	<pre> <code>
	: :NONAME ( --xt)
		HERE
		zero last !
		@s csp !
		TRUE STATE !
		FALSE _%local_use !
		_%save_op @ IF
			2F0A W,  \ ##code OP R -) MOV
			245E W,  \ ##code S )+ OP MOV
		THEN
	;
	</code> </pre>
<a name="]"></a>
<h5>6.1.2540 ]</h5>
<p>right-bracket CORE</p>
<p>( -- )</p>
<p>Enter compilation state.</p>
	<pre> <code>
    : ] ( --)
		TRUE STATE !
    ;
	</code> </pre>
<a name="["></>
<h5>6.1.2500 [</h5>
<p>left-bracket CORE</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: Perform the execution semantics given below.</p>
<p>Execution: ( -- )</p>
<p>Enter interpretation state. [ is an immediate word.</p>

	<pre> <code>
    : [ ( --)
		FALSE STATE !
	; IMMEDIATE
	</code> </pre>
<a name="2VARIABLE"></a>
<h5>8.6.1.0440 2VARIABLE</h5>
<p>two-variable DOUBLE</p> 
<p>( "name" -- )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space. 
Create a definition for name with the execution semantics defined
below. Reserve two consecutive cells of data space. 
</p>
<p>
name is referred to as a two-variable. 
</p>
<p>name Execution: ( -- a-addr )</p>
<p>
a-addr is the address of the first (lowest address) cell of two consecutive
cells in data space reserved by 2VARIABLE when it
defined name. A program is responsible for initializing the contents.
</p>
	<pre> <code>
	: 2VARIABLE \ parent ( --)
	            \ child ( --addr)
		CREATE 2 CELLS ALLOT
	;
	</code> </pre>
<a name="VARIABLE"></a>
<h5>6.1.2410 VARIABLE</h5>
<p>CORE</p>
<p>( "name" -- )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space.
Create a definition for name with the execution semantics defined
below. Reserve one cell of data space at an aligned address.
</p>
<p>
name is referred to as a variable.
</p>
<p>
name Execution: ( -- a-addr )
</p>
<p>
a-addr is the address of the reserved cell. A program is responsible
for initializing the contents of the reserved cell.
</p>
	<pre> <code>
	: VARIABLE \ parent ( --)
	            \ child ( --)
		CREATE cell ALLOT
	;
	</code> </pre>
<a name="ram_create"><h5>ram_create</h5></a>
<p>
Ram variable are preset to zero on a system restart.
</p>
	<pre> <code>
	: ram_create \ parent( --)
		         \ child ( -- addr)
		ram_here CONSTANT
	;

        </code> </pre>
<a name="ram_variable"><h5>ram_variable</h5></a>
	<pre> <code>

	: ram_variable ( --)
		ram_create four ram_allot
	;
	</code> </pre>
<a name="fast_create"><h5>fast_create</h5></a>
<p>
fast variable reside on the CPU chip, They are not reset on a system restart. They
can be used to store data threw a power on reset.
</p>
	<pre> <code>
	: fast_create \ child ( --addr)
		fast_here CONSTANT
	;

        </code> </pre>
<a name="fast_variable"><h5>fast_variable</h5></a>
	<pre> <code>

	: fast_variable ( --)
    	fast_create four fast_allot
    ;
    </code> </pre>
<a name="port_create"><h5>port_create</h5></a>

<p>
port variable
</p>
	<pre> <code>
	: port_create ( --addr)
		port_here CONSTANT
	;

        </code> </pre>
<a name="port_variable"><h5>port_variable</h5></a>
	<pre> <code>

    : port_variable ( --)
    	port_create four port_allot
    ;
    </code> </pre>
<a name="static_create"><h5>static_create</h5></a>

<p>
static variable
</p>
	<pre> <code>
#BVP5552 #BVP5551 + [IF]
	: static_create ( --addr)
		static_here CONSTANT
	;

        </code> </pre>
<a name="static_variable"><h5>static_variable</h5></a>
	<pre> <code>

    : static_variable ( --)
	static_create four static_allot
    ;
[THEN]
    </code> </pre>
<a name="bank_create"><h5>bank_create</h5></a>
	<pre> <code>
#BVP5552 #BVP6552 +  [IF]
	: bank_create ( --addr)
		bank_here CONSTANT
	;

        </code> </pre>
<a name="bank_variable"><h5>bank_variable</h5></a>
	<pre> <code>
    : bank_variable ( --)
    	bank_create four bank_allot
    ;
[THEN]
    </code> </pre>

<a name="backslash"></a>
<h5>6.2.2535 \</h5>
<p>backslash CORE EXT</p>
<p>Compilation: Perform the execution semantics given below.</p>
<p>Execution: ( "ccc"-- )</p>
<p>
Parse and discard the remainder of the parse area. \ is an immediate word.
</p>
	<pre> <code>
    : \  ( --)
    	#TIB @ >IN !
    ; IMMEDIATE
	</code> </pre>
<p>
Compile codes. Used to check that strcutures are correctly formed.
</p>   
	<pre> <code>
	1                      CONSTANT _#comp_code_origin
	2                      CONSTANT _#comp_code_destination
	3                      CONSTANT _#comp_code_do_origin
	4                      CONSTANT _#comp_code_do_destination
	5                      CONSTANT _#comp_code_leave

	0A                     CONSTANT _#comp_code_task
	</code> </pre>
<p>
We are going to resolve LEAVE at compile time.
As a result all control structures other than ?D0 and DO
have to roll out the start code from under the leave codes.
The leave codes are resolved at compile time by DO and ?DO.
The advantage, we dont have to put the termination address on
the stack at runtime.
</p>
	<pre> <code>
	| : roll_out_initiator 
		zero >R
		BEGIN
			R@ CS-PICK NIP
			_#comp_code_leave =
		WHILE
			R> 1 + >R
		REPEAT
		R> CS-ROLL
	;
	
    |  : ?pair  ( n1 n1 -- ) 
    	- ABORT" Conditionals not matched" 
    ;
  		

	\ resolve a destination
    | : !back  (  addr --)   
    	HERE  -  W, 
    ;
	
	\ resolve an origin
	| : !forward ( addr --) HERE OVER -  SWAP W! ;

    </code> </pre>
<a name="AHEAD">	
<h5>5.6.2.0702 AHEAD</h5> 
<p>TOOLS EXT</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- orig )</p>
<p>
Put the location of a new unresolved forward reference orig onto the control flow stack. Append the run-time semantics given
below to the current definition. The semantics are incomplete until orig is resolved (e.g., by THEN). 
</p>
<p>Run-time: ( -- )</p>
<p>
Continue execution at the location specified by the resolution of orig.
</p>
	 <pre> <code>
	 \ supply an origin
	: AHEAD    \ runtime ( --)
	           \ compile time ( addr #code_origin --)
		6000 W, \ ##code BRA
		HERE two ALLOT _#comp_code_origin 
    ;  IMMEDIATE 
	</code> </pre>
<a name="BEGIN"></a>
<h5>6.1.0760 BEGIN</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- dest )</p>
<p>Put the next location for a transfer of control, dest, onto the control 
flow stack. Append the run-time semantics given below to the
current definition.</p>
<p>Run-time: ( -- )</p>
<p>Continue execution.<p>
	
	<pre> <code>
	\ supply a destination
    : BEGIN     \ runtime ( -- )
	            \ compile time ( addr #code_destination--)   
    	HERE 
		_#comp_code_destination
    ; IMMEDIATE
    </code> </pre>
<a name="UNTIL"></a>
<h5>6.1.2390 UNTIL</h5> 
<p>CORE</h5> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: dest -- )</p>
<p>Append the run-time semantics given below to the current definition, 
resolving the backward reference dest.</p>
<p>Run-time: ( x -- )</p>
<p>If all bits of x are zero, continue execution at the location 
specified by dest.</p>

	<pre> <code> 
	\ resolve destintion
	: UNTIL     \ runtime ( flag --)
	            \ compie time ( addr #code_destination ??leave --)
		roll_out_initiator
		_#comp_code_destination ?pair 
		4A9E W,   \ ##code S )+ TST
		6700 W,   \ ##code EQ BCC
		!back 
    ;  IMMEDIATE
	</code> </pre>
<a name="AGAIN">	   
<h5>6.2.0700 AGAIN</h5> 
<p>CORE EXT</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: dest -- )</p>
<p>Append the run-time semantics given below to the current definition, 
resolving the backward reference dest.</p> 
<p>Run-time: ( -- )</p>
<p>Continue execution at the location specified by dest. If no other
control flow words are used, any program code after AGAIN will
not be executed. 
</p>

	<pre> <code>
    : AGAIN     \ runtime ( --) 
	            \ compile time ( addr #code_destination ??leave --)
		roll_out_initiator
		_#comp_code_destination ?pair
		6000 W, \ ##code BRA
		!back 
    ;  IMMEDIATE
    </code> </pre>
<a name="THEN"></a>
<h5>6.1.2270 THEN</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: orig -- )</p>
<p>
Append the run-time semantics given below to the current definition. 
Resolve the forward reference orig using the location of the
appended run-time semantics.
</p> 
<p>Run-time: ( -- )</p>
<p>Continue execution.</p>     
	
	<pre> <code>
	: THEN      \ runtime ( --) 
	            \ compile time ( addr #code_origin ??leave --)
		roll_out_initiator
		_#comp_code_origin ?pair
		!forward
    ;  IMMEDIATE
	</code> </pre>
<a name="IF"></a>   
<h5>6.1.1700 IF</h5> 
<p>CORE</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- orig )</p>
<p>
Put the location of a new unresolved forward reference orig onto 
the control flow stack. Append the run-time semantics given
below to the current definition. The semantics are incomplete until 
orig is resolved, e.g., by THEN or ELSE.
</p> 
<p>Run-time: ( x -- )</p>
<p>
If all bits of x are zero, continue execution at the location 
specified by the resolution of orig. 
</p>

	<pre> <code>
	\ supplies origin
    : IF        \ runtime ( flag --)
	            \ compile time (  -- addr 2)
		4A9E W, \ ##code S )+ TST
		6700 W, \ ##code EQ BCC
		HERE two ALLOT _#comp_code_origin
    ;  IMMEDIATE 
	</code> </pre>
<a name="WHILE"></a>
<h5>6.1.2430 WHILE</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: dest -- orig dest )</p>
<p>
Put the location of a new unresolved forward reference orig onto the 
control flow stack, under the existing dest. Append the
run-time semantics given below to the current definition. 
The semantics are incomplete until orig and dest are resolved (e.g., by REPEAT).
</p> 
<p>Run-time: ( x -- )</p>
<p>
If all bits of x are zero, continue execution at the location specified 
by the resolution of orig.
</p> 

	<pre> <code>
	\ takes an destination
	\ supplies a origin destination
	: WHILE   \ runtime ( flag -- )
	          \ compile time (  addr1 destination ??leave -- addr2 origin addr1 dest)
		roll_out_initiator
		[COMPILE] IF 1 CS-ROLL 
	;  IMMEDIATE 
	</code> </pre>
<a name="REPEAT"></a>
<h5>6.1.2140 REPEAT</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: orig dest -- )</p>
<p>
Append the run-time semantics given below to the current definition, 
resolving the backward reference dest. Resolve the forward
reference orig using the location following the appended run-time semantics. 
</p>
<p>Run-time: ( -- )</p>
<p>Continue execution at the location given by dest.</p> 
    
	<pre> <code>
	\ takes destination origin
    : REPEAT \ runtime ( -- ) 
	         \ compile time ( addr2 origin ??leave addr1 dest ??leave --)
    	[COMPILE] AGAIN   
		[COMPILE] THEN 
    ;  IMMEDIATE 
	</code> </pre>
<a name="ELSE"></a>
<h5>6.1.1310 ELSE</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: orig1 -- orig2 )</p>
<p>
Put the location of a new unresolved forward reference orig2 onto 
the control flow stack. Append the run-time semantics given
below to the current definition. The semantics will be incomplete 
until orig2 is resolved (e.g., by THEN). Resolve the forward
reference orig1 using the location following the appended run-time semantics.
</p> 
<p>Run-time: ( -- )</p>
<p>
Continue execution at the location given by the resolution of orig2.
</p>

	<pre> <code>     
	: ELSE   \ runtime ( -- )
	         \ compile time ( addr1 2 -- addr2 2 )
		[COMPILE] AHEAD 
		1 CS-ROLL
		[COMPILE] THEN
	;  IMMEDIATE
	</code> </pre>
<a name="DO"></a>
<h5>6.1.1240 DO</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- do-sys )</p>
<p>
Place do-sys onto the control-flow stack. Append the run-time 
semantics given below to the current definition. The semantics are
incomplete until resolved by a consumer of do-sys such as LOOP.
</p> 
<p>Run-time: ( n1|u1 n2|u2 -- ) ( R: -- loop-sys )</p>
<p>
Set up loop control parameters with index n2|u2 and limit n1|u1. 
An ambiguous condition exists if n1|u1 and n2|u2 are not both the
same type. Anything already on the return stack becomes unavailable 
until the loop-control parameters are discarded. 
</p>
	<pre> <code>
    : DO    \ runtime ( limit start -- ) 
	        \ compile_time ( -- addr 3 )
    	COMPILE _do_do 
		HERE _#comp_code_do_destination
    ;  IMMEDIATE 
    </code> </pre>
<a name="questionDO"></a>
<h5>6.2.0620 ?DO</h5> 
<p>question-do CORE EXT</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- do-sys )</p>
<p>
Put do-sys onto the control-flow stack. Append the run-time semantics 
given below to the current definition. The semantics are
incomplete until resolved by a consumer of do-sys such as LOOP.
</p> 
<p>Run-time: ( n1|u1 n2|u2 -- ) ( R: --  | loop-sys )</p>
<p>
If n1|u1 is equal to n2|u2, continue execution at the location 
given by the consumer of do-sys. Otherwise set up loop control
parameters with index n2|u2 and limit n1|u1 and continue executing 
immediately following ?DO. Anything already on the return
stack becomes unavailable until the loop control parameters 
are discarded. An ambiguous condition exists if n1|u1 and n2|u2 are
not both of the same type.
</p>
 
	<pre> <code>
    : ?DO   \ runtime ( limit start --) 
	        \ compile time (-- addr -3 )
    	COMPILE _do_?do HERE _#comp_code_do_origin 2 ALLOT 
		HERE _#comp_code_do_destination 
    ; IMMEDIATE 
    </code> </pre>
<a name="LOOP"></a>
<h5>6.1.1800 LOOP</h5> 
<p>CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: do-sys -- )</p>
<p>
Append the run-time semantics given below to the current definition. 
Resolve the destination of all unresolved occurrences of
LEAVE between the location given by do-sys and the next location for a 
transfer of control, to execute the words following the
LOOP. 
</p>
<p>Run-time: ( -- ) ( R:  loop-sys1 --  | loop-sys2 )</p>
<p>
An ambiguous condition exists if the loop control parameters are unavailable. 
Add one to the loop index. If the loop index is then
equal to the loop limit, discard the loop parameters and continue execution 
immediately following the loop. Otherwise continue
execution at the beginning of the loop. 
</p>
<p>    
The stack should contain leave pairs and then a DO or ?DO destination.
If we roll_out_destination first then we may incorrectly compile
leaves from the previous loops. So we deal with the leaves and expect to
find a DO or ?DO destination.
</p>


	<pre> <code>
    : LOOP  ( -- \ addr 3 --)
		COMPILE _do_loop
		2 ALLOT
		BEGIN
			DUP _#comp_code_leave =
		WHILE
			DROP
			!forward
		REPEAT
    	_#comp_code_do_destination ?pair
		-2 ALLOT
		!back
		_#comp_code_do_origin OVER = IF
    	   DROP !forward
		THEN
    ;  IMMEDIATE 
	</code> </pre>


<a name="+LOOP"></a>
<h5>ANS 6.1.0140 +LOOP</h5> 

<p> Interpretation: Interpretation semantics for this word are undefined.
<br>Compilation: ( C: do-sys -- )
<br>
Append the run-time semantics given below to the current definition. 
Resolve the destination of all unresolved occurrences of LEAVE between 
the location given by do-sys and the next location for a transfer of control, 
to execute the words following +LOOP. 
<br>
Run-time: ( n -- ) ( R: loop-sys1 -- | loop-sys2 )
<br>
An ambiguous condition exists if the loop control parameters are unavailable. 
Add n to the loop index. If the loop index did not cross the boundary between the loop
limit minus one and the loop limit, continue execution at the beginning of the loop. 
Otherwise, discard the current loop control parameters and continue execution
immediately following the loop. 
</p>
<samp>
Typical use: : X ... limit first DO ... step +LOOP ; 
</samp>
<p>    
The stack should contain leave pairs and then a DO or ?DO initiator.
If we roll_out_iniator first then we may incorrectly compile
leaves from the previous loops. So we deal with the leaves and expect
to finish leave resolution when we hit the DO or ?DO initiator.
</p>

	<pre> <code>
    : +LOOP  ( n-- \ addr 3 --)
		COMPILE _do_+loop
		\ get the address right for all the resolves
		2 ALLOT
		BEGIN
			DUP _#comp_code_leave =
		WHILE
			DROP
			!forward
		REPEAT
    	_#comp_code_do_destination ?pair
		-2 ALLOT
		!back
		_#comp_code_do_origin OVER = IF
    	   DROP !forward
		THEN
    ;  IMMEDIATE 
    HEX
	</code> </pre>
<a name="LEAVE"></a>
<h5>ANS 6.1.1760 LEAVE</h5> 
<p>CORE</p>
<p>
Interpretation: Interpretation semantics for this word are undefined.
</p>
<p>Execution: ( -- ) ( R: loop-sys -- )</p>
<p>
Discard the current loop control parameters. An ambiguous condition
exists if they are unavailable. Continue execution immediately following
the innermost syntactically enclosing DO ... LOOP or DO ... +LOOP. 
</p>
Note that LEAVE immediately exits the loop. No words following
LEAVE within the loop will be executed. Typical use: 
</p>
<samp> 
: X ... DO ... IF ... LEAVE THEN ... LOOP ... ;
</samp>

	<pre> <code>
	: LEAVE   \ runtime ( -- )
	              \ compile time ( -- addr leave_code )
		508F W,  \ ##code 8 # R ADD
		6000 W,  \ ##code BRA
		HERE 2 ALLOT 
      	_#comp_code_leave
    ;  IMMEDIATE
	</code> <pre>
 <a name="CASE"></a>
<h5>6.2.0873 CASE</h5> 
<p>CORE EXT</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- case-sys )</p>
<p>Mark the start of the CASE ... OF ... ENDOF ... ENDCASE structure. 
Append the run-time semantics given below to the current
definition.</p> 
<p>Run-time: ( -- )</p>
<p>Continue execution.</p> 
<pre> <samp>
Typical use: 

   : X ...
       CASE
       test1 OF ... ENDOF
       testn OF ... ENDOF
       ... ( default )
       ENDCASE ...
   ;
</samp> </pre>

	<pre> <code>
	0 CONSTANT CASE IMMEDIATE  \  init count of OF 
	</code> </pre> 
<a name="OF"></a>
<h5>6.2.1950 OF</h5> 
<p>CORE EXT</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: -- of-sys )</p>
<p>
Put of-sys onto the control flow stack. Append the run-time semantics 
given below to the current definition. The semantics are
incomplete until resolved by a consumer of of-sys such as ENDOF.
</p> 
<p>Run-time: ( x1 x2 --   | x1 )</p>
<p>
If the two values on the stack are not equal, discard the top value 
and continue execution at the location specified by the consumer
of of-sys, e.g., following the next ENDOF. Otherwise, discard both 
values and continue execution in line. 
</p>

	<pre> <code>
	: OF  \ compile time ( #of -- orig #of+1 
          \ runtime      ( xtest x -- xtest)
		1+    \ count OFs
		>R    \ move off the stack as the control-flow )
		      \ stack is the data stack.

		COMPILE OVER
		COMPILE =       \ copy and test case value)
		[COMPILE] IF    \ add orig to control flow stack )
		COMPILE DROP    \ discards case value if =

		R>              \ we can bring count back now
	; IMMEDIATE
	</code> </pre>
<a name="ENDOF"></a>
<h5>6.2.1343 ENDOF</h5>
<p>end-of CORE EXT</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: case-sys1 of-sys -- case-sys2 )</p>
<p>
Mark the end of the OF ... ENDOF part of the CASE structure.
The next location for a transfer of control resolves the reference
given by of-sys. Append the run-time semantics given below to
the current definition. Replace case-sys1 with case-sys2 on the
control-flow stack, to be resolved by ENDCASE.
</p>
<p>Run-time: ( -- )</p>
<p>
Continue execution at the location specified by the consumer of case-sys2.
</p>

	<pre> <code>
	: ENDOF  \ compile time ( orig1 #of -- orig2 #of )
		>R   \ move off the stack as the control-flow )
             \ stack is the data stack. )
		[COMPILE] ELSE
		R>   ( we can bring count back now )
	; IMMEDIATE
	</code> </pre>

 <a name="ENDCASE"></a>
<h5>6.2.1342 ENDCASE</h5>
<p>end-case CORE EXT</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: case-sys -- )</p>
<p>Mark the end of the CASE ... OF ... ENDOF ... ENDCASE structure.
Use case-sys to resolve the entire structure. Append the
run-time semantics given below to the current definition.
</p>
<p>Run-time: ( x -- )</p>
<p>
Discard the case selector x and continue execution.
</p>

	<pre> <code>
	: ENDCASE  \ compile time ( orig1..orign #of -- )
		COMPILE DROP  ( discard case value )
		0 ?DO
			[COMPILE] THEN
		LOOP
	; IMMEDIATE
	</code> </pre>

<a name="gtR"></a>
<h5>ANS 6.1.0580 >R</h5>
<p>CORE</p>
<p>
Interpretation: Interpretation semantics for this word are undefined.
</p>
<p>Execution: ( x -- ) ( R:  -- x )</p>
<p>
Move x to the return stack.
</p>

	<pre> <code>
	: >R  ( --\ -- 32b)
		2F1E W,  \ ##code S )- R )+ MOV
	;   IMMEDIATE

</code> </pre>
	<a name="I"></a>
	<h5>ANS 6.1.1680 I</h5>

	<p>Interpretation: Interpretation semantics for this word are undefined.</p>

	<p>Execution: ( -- n|u ) ( R:  loop-sys -- loop-sys )</p>
	<p>
	n|u is a copy of the current (innermost) loop index. An ambiguous
	condition exists if the loop control parameters are unavailable.
	</p>

<pre> <code>
	: I ( --x)
		2D17 W,  \ ##code R ) S -) MOV
	;   IMMEDIATE


</code> </pre>
<a name="Rgt"></a>
<h5>ANS 6.1.2060 R></h5>

<p>Interpretation: Interpretation semantics for this word are undefined.
<br>
Execution: ( -- x ) ( R:  x -- )</p>
<p>
Move x from the return stack to the data stack.
<p>

	<pre> <code>
	: R>   ( - 32b)
		2D1F W, \ ##code R )+ S -) MOV
	;   IMMEDIATE

</code> </pre>
<a name="R@"></a>
<h5>ANS 6.1.2070 R@</h5>
<p>
Interpretation: Interpretation semantics for this word are undefined.
<br>
Execution: ( -- x ) ( R:  x -- x )</p>
<p>
Copy x from the return stack to the data stack.
</p>

	<pre> <code>
	: R@ ( --x)
		2D17 W,  \ ##code R ) S -) MOV
	;   IMMEDIATE

</code> </pre>
<a name="2gtR"></a>
<h5>ANS 6.2.0340 2>R</h5>
<p>CORE EXT</p>
<p>
Interpretation: Interpretation semantics for this word are undefined.
<br>
Execution: ( x1 x2 -- ) ( R:  -- x1 x2 )</p>
<p>
Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
SWAP >R >R .
<br>
Historically, 2>R has been used to implement DO. Hence the order of parameters on
the return stack.
</p>
<p>
The primary advantage of 2>R is that it puts the top stack entry on the top
of the return stack. For instance, a double-cell number may be transferred to the return
stack and still have the most significant cell accessible on the top of the return stack.
</p>
	<pre> <code>
	: 2>R
		201E W, \ ##code S )+ D0 MOV
		2F1E W, \ ##code S )+ R -) MOV
		2F00 W, \ ##code D0 R -) MOV
	;   IMMEDIATE
	</code> </pre>

<a name="2Rgt"></a>
<h5>ANS 6.2.0410 2R></h5>
<p>CORE EXT</p>
<p>
Interpretation: Interpretation semantics for this word are undefined.
<br>
Execution: ( -- x1 x2 ) ( R:  x1 x2 -- )</p>
<p>
Transfer cell pair x1 x2 from the return stack. Semantically equivalent to
R> R> SWAP .
</p>
<p>
Note that 2R> is not equivalent to R> R>. Instead, it mirrors the action
of 2>R
</p>

	<pre> <code>
	: 2R>
		201F W, \ ##code R )+ D0 MOV
		2D1F W, \ ##code R )+ S -) MOV
		2D00 W, \ ##code D0 S -) MOB
	;  IMMEDIATE
	</code> </pre>

<a name="rgtdrop"></a>
<h5>r>drop</h5>
<p>
	Hard to beleive but this is not a standard word. Discard one return stack item.
</p>

	<pre> <code>
	: r>drop ( --)
		588F W,   \ ##code 4 # R ADD
	;  IMMEDIATE
	</code> </pre>

<a name="2rgtdrop"></a>
<h5>2r>drop</h5>
<p>
	Remove two items from the return stack
</p>

    <pre> <code>
	: 2r>drop ( --)
		508F W,	\ ##code 8 # R ADD
	;  IMMEDIATE
	</code> </pre>
<a name="4rgtdrop"></a>
<h5>4r>drop</h5>
<p>
	Remove four items from the return stack
</p>
<pre> <code>
	: 4r>drop ( --)
		508F W,	\ ##code 8 # R ADD
		508F W,	\ ##code 8 # R ADD
	;  IMMEDIATE
	</code> </pre>

<a name="dupgtr"></a>
<h5>dup>r</h5>
<p>
	Duplicate the top stack item and send it to the return stack.
</p>

	<pre> <code>
	: dup>r ( --)
		2F16 W, \ ##code S ) R -) MOV
	;   IMMEDIATE
	</code> </pre>
<a name="semicolon"></a>
<h5>6.1.0460 ;</h5>
<p>semicolon CORE</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: colon-sys -- )</p>
<p>
Append the run-time semantics below to the current definition.
End the current definition, allow it to be found in the dictionary and
enter interpretation state, consuming colon-sys. If the data-space
pointer is not aligned, reserve enough data space to align it.
</p>
<p>
Run-time: ( -- ) ( R: nest-sys -- )
</p>
<p>
Return to the calling definition specified by nest-sys.
</p>
	<pre> <code>
	: ;
		\ word exit code
		_%local_use @ IF
			_%local_output_bytes @ IF
				_%local_output_bytes @ 4 / 7000 OR W, \ ##code # D0 MOV
				204D W,                               \ ##cope LP A0 MOV
				                                      \ ##code BEGIN
				2D20 W,                               \ ##code A0 -) S -) MOV
				5380 W,                               \ ##code 1 # D0 SUB
				66FA W,								  \ ##code EQ UNTIL
			THEN
			4E5D W,                               \ ##code LP UNLK
			PREVIOUS  \ get rid of &local
			_end_local_dictionary
		THEN
		_%save_op @ IF
			zero _%save_op !
			245F W,  \ ##code R )+ OP MOV
		THEN
		4E75 W,                                       \ ##code RTS
		smudge
		@s csp @ ?pair
		[COMPILE] [
	;	IMMEDIATE
	</code> </pre>
<a name="EXIT"></a>
<h5>6.1.1380 EXIT</h5>
<p>CORE</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Execution: ( -- ) ( R: nest-sys -- )</p>
<p>
Return control to the calling definition specified by nest-sys.
Before executing EXIT within a do-loop, a program shall discard the
loop-control parameters by executing UNLOOP.
</p>
	<pre> <code>
	: EXIT
		\ word exit code
		_%local_use @ IF
			_%local_output_bytes @ IF
				_%local_output_bytes @ 4 / 7000 OR W, \ ##code # D0 MOV
				204D W,                               \ ##cope LP A0 MOV
													  \ ##code BEGIN
				2D20 W,                               \ ##code A0 -) S -) MOV
				5380 W,                               \ ##code 1 # D0 SUB
				66FA W,								  \ ##code EQ UNTIL
			THEN
				4E5D W,                               \ ##code LP UNLK
		THEN
		_%save_op @ IF
			245F W,  \ ##code R )+ OP MOV
		THEN
		4E75 W,                                       \ ##code RTS
	;	IMMEDIATE
	</code> </pre>
<a name="semicolon_code"></a>
	<h5>15.6.2.0470 ;CODE</h5>
<p>semicolon-code TOOLS EXT</p>
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: colon-sys -- )</p>
<p>
Append the run-time semantics below to the current definition.
End the current definition, allow it to be found in the dictionary, and
enter interpretation state, consuming colon-sys.
</p>
<p>
Subsequent characters in the parse area typically represent source code
in a programming language, usually some form of assembly
language. Those characters are processed in an implementation-defined
manner, generating the corresponding machine code. The
process continues, refilling the input buffer as needed, until an
implementation-defined ending sequence is processed.
</p>
<p>Run-time: ( -- ) ( R: nest-sys -- )</p>
<p>
Replace the execution semantics of the most recent definition with
the name execution semantics given below. Return control to the
calling definition specified by nest-sys. An ambiguous condition
exists if the most recent definition was not defined with CREATE or
a user-defined word that calls CREATE.
</p>
<p>name Execution: ( i*x -- j*x )</p>
<p>
Perform the machine code sequence that was generated following ;CODE.
</p>
	<pre> <code>
    : ;CODE  ( -- \ --)
                \ this code is for the : in the parent
                _%local_use @ IF
			_%local_output_bytes @ IF
				_%local_output_bytes @ 4 / 7000 OR W, \ ##code # D0 MOV
				204D W,                               \ ##cope LP A0 MOV
				                                      \ ##code BEGIN
				2D20 W,                               \ ##code A0 -) S -) MOV
				5380 W,                               \ ##code 1 # D0 SUB
				66FA W,								  \ ##code EQ UNTIL
			THEN
			4E5D W,                               \ ##code LP UNLK
			PREVIOUS  \ get rid of &local
			_end_local_dictionary
		THEN
		_%save_op @ IF
			zero _%save_op !
			245F W,  \ ##code R )+ OP MOV
		THEN

                COMPILE ;code

                \ return address is data field address of child
                285F W,  \ ##CODE R )+ W MOV
		\ ;code points the cf of the just CREATEd word to the following cell
		\ and exits this word. The return stack has to be ready for
		\ exit before ;code is called. ;CODE is a valid terminator for
		\ a m: word.
		smudge
		[COMPILE] [
      	        init_assembler
		ALSO ASSEMBLER
		FALSE _%local_use !
    ;  IMMEDIATE
	</code> </pre>
<a name="DOES"></a>
<h5>6.1.1250 DOES></h5> 
<p>does CORE</p> 
<p>Interpretation: Interpretation semantics for this word are undefined.</p>
<p>Compilation: ( C: colon-sys1 -- colon-sys2 )</p>
<p>
Append the run-time semantics below to the current definition. 
Whether or not the current definition is rendered findable in the
dictionary by the compilation of DOES> is implementation defined. 
Consume colon-sys1 and produce colon-sys2. Append the
initiation semantics given below to the current definition.
</p> 
<p>
Run-time: ( -- ) ( R: nest-sys1 -- )
</p>
<p>
Replace the execution semantics of the most recent definition, 
referred to as name, with the name execution semantics given below.
Return control to the calling definition specified by nest-sys1. 
An ambiguous condition exists if name was not defined with CREATE
or a user-defined word that calls CREATE.
</p> 
<p>
Initiation: ( i*x -- i*x a-addr ) ( R:  -- nest-sys2 )
</p>
<p>
Save implementation-dependent information nest-sys2 about the calling 
definition. Place name's data field address on the stack. The
stack effects i*x represent arguments to name.
</p> 
<p>
name Execution: ( i*x -- j*x )
</p>
<p>
Execute the portion of the definition that begins with the initiation 
semantics appended by the DOES> which modified name. The
stack effects i*x and j*x represent arguments to and results from name, 
respectively. 
</p>
	<pre> <code>
    : DOES> ( -- addr \ --)
		\ word exit code
		_%local_use @ IF
			_%local_output_bytes @ IF
				_%local_output_bytes @ 4 / 7000 OR W, \ ##code # D0 MOV
				204D W,                               \ ##cope LP A0 MOV
				                                      \ ##code BEGIN
				2D20 W,                               \ ##code A0 -) S -) MOV
				5380 W,                               \ ##code 1 # D0 SUB
				66FA W,								  \ ##code EQ UNTIL
			THEN
			4E5D W,								      \ ##code LP UNLK
			PREVIOUS  \ get rid of &local
			_end_local_dictionary
		THEN  
		_%save_op @ IF
			zero _%save_op !
			245F W,  \ ##code R )+ OP MOV
		THEN
		\ ;code points the code field of the last defined word
		\ to the cell following ;code and exits this word.
		\ Therefor we have to have the return stack values removed 
		\ before we call ;code. DOES> is a valid terminator for a m: word.
    	COMPILE ;code 
		 4EB9 W,  ( ##code AB L. JSR )
		['] _do_does> xt>cfa ,
		FALSE _%local_use !
    ;   IMMEDIATE
	</code> </pre>
<a name="CODE"></a>
<h5>15.6.2.0930 CODE</h5> 
<p>TOOLS EXT</p> 
<p>( "name" -- )</p>
<p>
Skip leading space delimiters. Parse name delimited by a space. 
Create a definition for name, called a code definition, with the
execution semantics defined below.
</p> 
<p>
Subsequent characters in the parse area typically represent source 
code in a programming language, usually some form of assembly
language. Those characters are processed in an implementation-defined 
manner, generating the corresponding machine code. The
process continues, refilling the input buffer as needed, 
until an implementation-defined ending sequence is processed.
</p> 
<p>
name Execution: ( i*x -- j*x )
</p>
<p>
Execute the machine code sequence that was generated following CODE. 
</p>
<p>
Note the assembler works in interpretive mode)
</p>

	<pre> <code> 
    : CODE ( --)
    	CREATE  
		_recover_cfa 
		init_assembler 
		ALSO ASSEMBLER  
		FALSE _%local_use !
    ;

    </code> </pre>
    
 <a name="vocabulary"></a>
<h5>vocabulary</h5>
<p>
This words creates children that behave as FORTH does
we supply wid so the following is allowed.
</p>
<pre> <samp>
	WORDLIST
	DUP vocabulary    FORTH
	name_wordlist FORTH-WORDLIST
</samp> </pre>


	<pre> <code>
	: last_wordname>   ( --addr)
		last        \ user variable
		@           \ address of haed last name added to
		@           \ lfa of last entry
		lfa>nfa  \
	;


	: vocabulary			\ parent ( wid --)
							\ child  ( --)
		CREATE last_wordname> OVER                \ wid name> wid (--
		[ _#voc_name> _#voc_wid - ]T LITERAL + ! 
		, 
		DOES>
			@ context !
	;
	</code> </pre>


<a name="name_wordlist"></a>
<h5>name_wordlist</h5>
<p>
This word creates children that behave as FORTH-WORDLIST does.
</p>


	<pre> <code>
	: name_wordlist         \ parent ( wid --)
							\ child  ( -- wid)
		CREATE ,
		DOES>
			@
		;
	</code> </pre>

</body>
</html>
